

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>perpetual.booster &mdash; Perpetual 1.0.25 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=9edc463e" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=c22798c2"></script>
      <script src="../../_static/doctools.js?v=fd6eb6e6"></script>
      <script src="../../_static/sphinx_highlight.js?v=6ffebe34"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Perpetual
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../architecture.html">Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../parameters_tuning.html">Parameters Tuning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../faq.html">Frequently Asked Questions</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../generated/perpetual.PerpetualBooster.html">perpetual.PerpetualBooster</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Perpetual</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">perpetual.booster</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for perpetual.booster</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">inspect</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">types</span><span class="w"> </span><span class="kn">import</span> <span class="n">FunctionType</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">cast</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing_extensions</span><span class="w"> </span><span class="kn">import</span> <span class="n">Self</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">perpetual.data</span><span class="w"> </span><span class="kn">import</span> <span class="n">Node</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">perpetual.perpetual</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">MultiOutputBooster</span> <span class="k">as</span> <span class="n">CrateMultiOutputBooster</span><span class="p">,</span>  <span class="c1"># type: ignore</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">perpetual.perpetual</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">PerpetualBooster</span> <span class="k">as</span> <span class="n">CratePerpetualBooster</span><span class="p">,</span>  <span class="c1"># type: ignore</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">perpetual.serialize</span><span class="w"> </span><span class="kn">import</span> <span class="n">BaseSerializer</span><span class="p">,</span> <span class="n">ObjectSerializer</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">perpetual.types</span><span class="w"> </span><span class="kn">import</span> <span class="n">BoosterType</span><span class="p">,</span> <span class="n">MultiOutputBoosterType</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">perpetual.utils</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">CONTRIBUTION_METHODS</span><span class="p">,</span>
    <span class="n">convert_input_array</span><span class="p">,</span>
    <span class="n">convert_input_frame</span><span class="p">,</span>
    <span class="n">convert_input_frame_columnar</span><span class="p">,</span>
    <span class="n">transform_input_frame</span><span class="p">,</span>
    <span class="n">transform_input_frame_columnar</span><span class="p">,</span>
    <span class="n">type_df</span><span class="p">,</span>
<span class="p">)</span>


<div class="viewcode-block" id="PerpetualBooster">
<a class="viewcode-back" href="../../generated/perpetual.PerpetualBooster.html#perpetual.PerpetualBooster">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">PerpetualBooster</span><span class="p">:</span>
    <span class="c1"># Define the metadata parameters</span>
    <span class="c1"># that are present on all instances of this class</span>
    <span class="c1"># this is useful for parameters that should be</span>
    <span class="c1"># attempted to be loaded in and set</span>
    <span class="c1"># as attributes on the booster after it is loaded.</span>
    <span class="n">metadata_attributes</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">BaseSerializer</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;feature_names_in_&quot;</span><span class="p">:</span> <span class="n">ObjectSerializer</span><span class="p">(),</span>
        <span class="s2">&quot;n_features_&quot;</span><span class="p">:</span> <span class="n">ObjectSerializer</span><span class="p">(),</span>
        <span class="s2">&quot;feature_importance_method&quot;</span><span class="p">:</span> <span class="n">ObjectSerializer</span><span class="p">(),</span>
        <span class="s2">&quot;cat_mapping&quot;</span><span class="p">:</span> <span class="n">ObjectSerializer</span><span class="p">(),</span>
        <span class="s2">&quot;classes_&quot;</span><span class="p">:</span> <span class="n">ObjectSerializer</span><span class="p">(),</span>
    <span class="p">}</span>

<div class="viewcode-block" id="PerpetualBooster.__init__">
<a class="viewcode-back" href="../../generated/perpetual.PerpetualBooster.html#perpetual.PerpetualBooster.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">objective</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
            <span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">FunctionType</span><span class="p">,</span> <span class="n">FunctionType</span><span class="p">,</span> <span class="n">FunctionType</span><span class="p">]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;LogLoss&quot;</span><span class="p">,</span>
        <span class="n">budget</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">num_threads</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">monotone_constraints</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">force_children_to_bound_parent</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">missing</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
        <span class="n">allow_missing_splits</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">create_missing_branch</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">terminate_missing_features</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">missing_node_treatment</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;None&quot;</span><span class="p">,</span>
        <span class="n">log_iterations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">feature_importance_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Gain&quot;</span><span class="p">,</span>
        <span class="n">quantile</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">reset</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">categorical_features</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="n">timeout</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">iteration_limit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">memory_limit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">stopping_rounds</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">max_bin</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">256</span><span class="p">,</span>
        <span class="n">max_cat</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gradient Boosting Machine with Perpetual Learning.</span>

<span class="sd">        A self-generalizing gradient boosting machine that doesn&#39;t need hyperparameter optimization.</span>
<span class="sd">        It automatically finds the best configuration based on the provided budget.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        objective : str or tuple, default=&quot;LogLoss&quot;</span>
<span class="sd">            Learning objective function to be used for optimization. Valid options are:</span>

<span class="sd">            - &quot;LogLoss&quot;: logistic loss for binary classification.</span>
<span class="sd">            - &quot;SquaredLoss&quot;: squared error for regression.</span>
<span class="sd">            - &quot;QuantileLoss&quot;: quantile error for quantile regression.</span>
<span class="sd">            - &quot;HuberLoss&quot;: Huber loss for robust regression.</span>
<span class="sd">            - &quot;AdaptiveHuberLoss&quot;: adaptive Huber loss for robust regression.</span>
<span class="sd">            - &quot;ListNetLoss&quot;: ListNet loss for ranking.</span>
<span class="sd">            - custom objective: a tuple of (grad, hess, init) functions.</span>

<span class="sd">        budget : float, default=0.5</span>
<span class="sd">            A positive number for fitting budget. Increasing this number will more likely result</span>
<span class="sd">            in more boosting rounds and increased predictive power.</span>
<span class="sd">        num_threads : int, optional</span>
<span class="sd">            Number of threads to be used during training and prediction.</span>
<span class="sd">        monotone_constraints : dict, optional</span>
<span class="sd">            Constraints to enforce a specific relationship between features and target.</span>
<span class="sd">            Keys are feature indices or names, values are -1, 1, or 0.</span>
<span class="sd">        force_children_to_bound_parent : bool, default=False</span>
<span class="sd">            Whether to restrict children nodes to be within the parent&#39;s range.</span>
<span class="sd">        missing : float, default=np.nan</span>
<span class="sd">            Value to consider as missing data.</span>
<span class="sd">        allow_missing_splits : bool, default=True</span>
<span class="sd">            Whether to allow splits that separate missing from non-missing values.</span>
<span class="sd">        create_missing_branch : bool, default=False</span>
<span class="sd">            Whether to create a separate branch for missing values (ternary trees).</span>
<span class="sd">        terminate_missing_features : iterable, optional</span>
<span class="sd">            Features for which missing branches will always be terminated if</span>
<span class="sd">            ``create_missing_branch`` is True.</span>
<span class="sd">        missing_node_treatment : str, default=&quot;None&quot;</span>
<span class="sd">            How to handle weights for missing nodes if ``create_missing_branch`` is True.</span>
<span class="sd">            Options: &quot;None&quot;, &quot;AssignToParent&quot;, &quot;AverageLeafWeight&quot;, &quot;AverageNodeWeight&quot;.</span>
<span class="sd">        log_iterations : int, default=0</span>
<span class="sd">            Logging frequency (every N iterations). 0 disables logging.</span>
<span class="sd">        feature_importance_method : str, default=&quot;Gain&quot;</span>
<span class="sd">            Method for calculating feature importance. Options: &quot;Gain&quot;, &quot;Weight&quot;, &quot;Cover&quot;,</span>
<span class="sd">            &quot;TotalGain&quot;, &quot;TotalCover&quot;.</span>
<span class="sd">        quantile : float, optional</span>
<span class="sd">            Target quantile for quantile regression (objective=&quot;QuantileLoss&quot;).</span>
<span class="sd">        reset : bool, optional</span>
<span class="sd">            Whether to reset the model or continue training on subsequent calls to fit.</span>
<span class="sd">        categorical_features : str or iterable, default=&quot;auto&quot;</span>
<span class="sd">            Feature indices or names to treat as categorical.</span>
<span class="sd">        timeout : float, optional</span>
<span class="sd">            Time limit for fitting in seconds.</span>
<span class="sd">        iteration_limit : int, optional</span>
<span class="sd">            Maximum number of boosting iterations.</span>
<span class="sd">        memory_limit : float, optional</span>
<span class="sd">            Memory limit for training in GB.</span>
<span class="sd">        stopping_rounds : int, optional</span>
<span class="sd">            Early stopping rounds.</span>
<span class="sd">        max_bin : int, default=256</span>
<span class="sd">            Maximum number of bins for feature discretization.</span>
<span class="sd">        max_cat : int, default=1000</span>
<span class="sd">            Maximum unique categories before a feature is treated as numerical.</span>

<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        feature_names_in_ : list of str</span>
<span class="sd">            Names of features seen during :meth:`fit`.</span>
<span class="sd">        n_features_ : int</span>
<span class="sd">            Number of features seen during :meth:`fit`.</span>
<span class="sd">        classes_ : list</span>
<span class="sd">            Class labels for classification tasks.</span>
<span class="sd">        feature_importances_ : ndarray of shape (n_features,)</span>
<span class="sd">            Feature importances calculated via ``feature_importance_method``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        perpetual.sklearn.PerpetualClassifier : Scikit-learn compatible classifier.</span>
<span class="sd">        perpetual.sklearn.PerpetualRegressor : Scikit-learn compatible regressor.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Basic usage for binary classification:</span>

<span class="sd">        &gt;&gt;&gt; from perpetual import PerpetualBooster</span>
<span class="sd">        &gt;&gt;&gt; from sklearn.datasets import make_classification</span>
<span class="sd">        &gt;&gt;&gt; X, y = make_classification(n_samples=1000, n_features=20)</span>
<span class="sd">        &gt;&gt;&gt; model = PerpetualBooster(objective=&quot;LogLoss&quot;)</span>
<span class="sd">        &gt;&gt;&gt; model.fit(X, y)</span>
<span class="sd">        &gt;&gt;&gt; preds = model.predict(X[:5])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">terminate_missing_features_</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">set</span><span class="p">()</span> <span class="k">if</span> <span class="n">terminate_missing_features</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">terminate_missing_features</span>
        <span class="p">)</span>
        <span class="n">monotone_constraints_</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">{}</span> <span class="k">if</span> <span class="n">monotone_constraints</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">monotone_constraints</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">objective</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">objective</span> <span class="o">=</span> <span class="n">objective</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loss</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grad</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">objective</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loss</span> <span class="o">=</span> <span class="n">objective</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grad</span> <span class="o">=</span> <span class="n">objective</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">objective</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">budget</span> <span class="o">=</span> <span class="n">budget</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span> <span class="o">=</span> <span class="n">num_threads</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">monotone_constraints</span> <span class="o">=</span> <span class="n">monotone_constraints_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">force_children_to_bound_parent</span> <span class="o">=</span> <span class="n">force_children_to_bound_parent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allow_missing_splits</span> <span class="o">=</span> <span class="n">allow_missing_splits</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing</span> <span class="o">=</span> <span class="n">missing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_missing_branch</span> <span class="o">=</span> <span class="n">create_missing_branch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">terminate_missing_features</span> <span class="o">=</span> <span class="n">terminate_missing_features_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing_node_treatment</span> <span class="o">=</span> <span class="n">missing_node_treatment</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_iterations</span> <span class="o">=</span> <span class="n">log_iterations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">feature_importance_method</span> <span class="o">=</span> <span class="n">feature_importance_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quantile</span> <span class="o">=</span> <span class="n">quantile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span> <span class="o">=</span> <span class="n">reset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">categorical_features</span> <span class="o">=</span> <span class="n">categorical_features</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">timeout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iteration_limit</span> <span class="o">=</span> <span class="n">iteration_limit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">memory_limit</span> <span class="o">=</span> <span class="n">memory_limit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stopping_rounds</span> <span class="o">=</span> <span class="n">stopping_rounds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_bin</span> <span class="o">=</span> <span class="n">max_bin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_cat</span> <span class="o">=</span> <span class="n">max_cat</span>

        <span class="n">booster</span> <span class="o">=</span> <span class="n">CratePerpetualBooster</span><span class="p">(</span>
            <span class="n">objective</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">objective</span><span class="p">,</span>
            <span class="n">budget</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">budget</span><span class="p">,</span>
            <span class="n">max_bin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_bin</span><span class="p">,</span>
            <span class="n">num_threads</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span><span class="p">,</span>
            <span class="n">monotone_constraints</span><span class="o">=</span><span class="nb">dict</span><span class="p">(),</span>
            <span class="n">force_children_to_bound_parent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">force_children_to_bound_parent</span><span class="p">,</span>
            <span class="n">missing</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">missing</span><span class="p">,</span>
            <span class="n">allow_missing_splits</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">allow_missing_splits</span><span class="p">,</span>
            <span class="n">create_missing_branch</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">create_missing_branch</span><span class="p">,</span>
            <span class="n">terminate_missing_features</span><span class="o">=</span><span class="nb">set</span><span class="p">(),</span>
            <span class="n">missing_node_treatment</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">missing_node_treatment</span><span class="p">,</span>
            <span class="n">log_iterations</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">log_iterations</span><span class="p">,</span>
            <span class="n">quantile</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quantile</span><span class="p">,</span>
            <span class="n">reset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">,</span>
            <span class="n">categorical_features</span><span class="o">=</span><span class="nb">set</span><span class="p">(),</span>
            <span class="n">timeout</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">,</span>
            <span class="n">iteration_limit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration_limit</span><span class="p">,</span>
            <span class="n">memory_limit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">memory_limit</span><span class="p">,</span>
            <span class="n">stopping_rounds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stopping_rounds</span><span class="p">,</span>
            <span class="n">loss</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loss</span><span class="p">,</span>
            <span class="n">grad</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grad</span><span class="p">,</span>
            <span class="n">init</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">init</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">booster</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">BoosterType</span><span class="p">,</span> <span class="n">booster</span><span class="p">)</span></div>


<div class="viewcode-block" id="PerpetualBooster.fit">
<a class="viewcode-back" href="../../generated/perpetual.PerpetualBooster.html#perpetual.PerpetualBooster.fit">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit the gradient booster on a provided dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : array-like of shape (n_samples, n_features)</span>
<span class="sd">            Training data. Can be a Polars or Pandas DataFrame, or a 2D Numpy array.</span>
<span class="sd">            Polars DataFrames use a zero-copy columnar path for efficiency.</span>
<span class="sd">        y : array-like of shape (n_samples,) or (n_samples, n_targets)</span>
<span class="sd">            Target values.</span>
<span class="sd">        sample_weight : array-like of shape (n_samples,), optional</span>
<span class="sd">            Individual weights for each sample. If None, all samples are weighted equally.</span>
<span class="sd">        group : array-like, optional</span>
<span class="sd">            Group labels for ranking objectives.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : object</span>
<span class="sd">            Returns self.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check if input is a Polars DataFrame for zero-copy columnar path</span>
        <span class="n">is_polars</span> <span class="o">=</span> <span class="n">type_df</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;polars_df&quot;</span>

        <span class="k">if</span> <span class="n">is_polars</span><span class="p">:</span>
            <span class="c1"># Use columnar path for Polars DataFrames (true zero-copy)</span>
            <span class="p">(</span>
                <span class="n">features_</span><span class="p">,</span>
                <span class="n">columns</span><span class="p">,</span>  <span class="c1"># list of 1D arrays instead of flat_data</span>
                <span class="n">masks</span><span class="p">,</span>
                <span class="n">rows</span><span class="p">,</span>
                <span class="n">cols</span><span class="p">,</span>
                <span class="n">categorical_features_</span><span class="p">,</span>
                <span class="n">cat_mapping</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">=</span> <span class="n">convert_input_frame_columnar</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">categorical_features</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_cat</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Use existing flat path for pandas and numpy</span>
            <span class="p">(</span>
                <span class="n">features_</span><span class="p">,</span>
                <span class="n">flat_data</span><span class="p">,</span>
                <span class="n">rows</span><span class="p">,</span>
                <span class="n">cols</span><span class="p">,</span>
                <span class="n">categorical_features_</span><span class="p">,</span>
                <span class="n">cat_mapping</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">=</span> <span class="n">convert_input_frame</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">categorical_features</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_cat</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_features_</span> <span class="o">=</span> <span class="n">cols</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cat_mapping</span> <span class="o">=</span> <span class="n">cat_mapping</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">feature_names_in_</span> <span class="o">=</span> <span class="n">features_</span>

        <span class="n">y_</span><span class="p">,</span> <span class="n">classes_</span> <span class="o">=</span> <span class="n">convert_input_array</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">objective</span><span class="p">,</span> <span class="n">is_target</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">classes_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">classes_</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">sample_weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sample_weight_</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sample_weight_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">convert_input_array</span><span class="p">(</span><span class="n">sample_weight</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">objective</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">group</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">group_</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">group_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">convert_input_array</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">objective</span><span class="p">,</span> <span class="n">is_int</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Convert the monotone constraints into the form needed</span>
        <span class="c1"># by the rust code.</span>
        <span class="n">crate_mc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_standardize_monotonicity_map</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">crate_tmf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_standardize_terminate_missing_features</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">classes_</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">classes_</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">objective</span> <span class="o">==</span> <span class="s2">&quot;SquaredLoss&quot;</span>
        <span class="p">):</span>
            <span class="n">booster</span> <span class="o">=</span> <span class="n">CratePerpetualBooster</span><span class="p">(</span>
                <span class="n">objective</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">objective</span><span class="p">,</span>
                <span class="n">budget</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">budget</span><span class="p">,</span>
                <span class="n">max_bin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_bin</span><span class="p">,</span>
                <span class="n">num_threads</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span><span class="p">,</span>
                <span class="n">monotone_constraints</span><span class="o">=</span><span class="n">crate_mc</span><span class="p">,</span>
                <span class="n">force_children_to_bound_parent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">force_children_to_bound_parent</span><span class="p">,</span>
                <span class="n">missing</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">missing</span><span class="p">,</span>
                <span class="n">allow_missing_splits</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">allow_missing_splits</span><span class="p">,</span>
                <span class="n">create_missing_branch</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">create_missing_branch</span><span class="p">,</span>
                <span class="n">terminate_missing_features</span><span class="o">=</span><span class="n">crate_tmf</span><span class="p">,</span>
                <span class="n">missing_node_treatment</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">missing_node_treatment</span><span class="p">,</span>
                <span class="n">log_iterations</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">log_iterations</span><span class="p">,</span>
                <span class="n">quantile</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quantile</span><span class="p">,</span>
                <span class="n">reset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">,</span>
                <span class="n">categorical_features</span><span class="o">=</span><span class="n">categorical_features_</span><span class="p">,</span>
                <span class="n">timeout</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">,</span>
                <span class="n">iteration_limit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration_limit</span><span class="p">,</span>
                <span class="n">memory_limit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">memory_limit</span><span class="p">,</span>
                <span class="n">stopping_rounds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stopping_rounds</span><span class="p">,</span>
                <span class="n">loss</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loss</span><span class="p">,</span>
                <span class="n">grad</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grad</span><span class="p">,</span>
                <span class="n">init</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">init</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">booster</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">BoosterType</span><span class="p">,</span> <span class="n">booster</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">booster</span> <span class="o">=</span> <span class="n">CrateMultiOutputBooster</span><span class="p">(</span>
                <span class="n">n_boosters</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">classes_</span><span class="p">),</span>
                <span class="n">objective</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">objective</span><span class="p">,</span>
                <span class="n">budget</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">budget</span><span class="p">,</span>
                <span class="n">max_bin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_bin</span><span class="p">,</span>
                <span class="n">num_threads</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span><span class="p">,</span>
                <span class="n">monotone_constraints</span><span class="o">=</span><span class="n">crate_mc</span><span class="p">,</span>
                <span class="n">force_children_to_bound_parent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">force_children_to_bound_parent</span><span class="p">,</span>
                <span class="n">missing</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">missing</span><span class="p">,</span>
                <span class="n">allow_missing_splits</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">allow_missing_splits</span><span class="p">,</span>
                <span class="n">create_missing_branch</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">create_missing_branch</span><span class="p">,</span>
                <span class="n">terminate_missing_features</span><span class="o">=</span><span class="n">crate_tmf</span><span class="p">,</span>
                <span class="n">missing_node_treatment</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">missing_node_treatment</span><span class="p">,</span>
                <span class="n">log_iterations</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">log_iterations</span><span class="p">,</span>
                <span class="n">quantile</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quantile</span><span class="p">,</span>
                <span class="n">reset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">,</span>
                <span class="n">categorical_features</span><span class="o">=</span><span class="n">categorical_features_</span><span class="p">,</span>
                <span class="n">timeout</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">,</span>
                <span class="n">iteration_limit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration_limit</span><span class="p">,</span>
                <span class="n">memory_limit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">memory_limit</span><span class="p">,</span>
                <span class="n">stopping_rounds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stopping_rounds</span><span class="p">,</span>
                <span class="n">loss</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loss</span><span class="p">,</span>
                <span class="n">grad</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grad</span><span class="p">,</span>
                <span class="n">init</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">init</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">booster</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">MultiOutputBoosterType</span><span class="p">,</span> <span class="n">booster</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_metadata_attributes</span><span class="p">(</span><span class="s2">&quot;n_features_&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_features_</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_metadata_attributes</span><span class="p">(</span><span class="s2">&quot;cat_mapping&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cat_mapping</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_metadata_attributes</span><span class="p">(</span><span class="s2">&quot;feature_names_in_&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_names_in_</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_metadata_attributes</span><span class="p">(</span>
            <span class="s2">&quot;feature_importance_method&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_importance_method</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_metadata_attributes</span><span class="p">(</span><span class="s2">&quot;classes_&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">classes_</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">categorical_features</span> <span class="o">=</span> <span class="n">categorical_features_</span>

        <span class="k">if</span> <span class="n">is_polars</span><span class="p">:</span>
            <span class="c1"># Use columnar fit for Polars (zero-copy)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">booster</span><span class="o">.</span><span class="n">fit_columnar</span><span class="p">(</span>
                <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
                <span class="n">masks</span><span class="o">=</span><span class="n">masks</span><span class="p">,</span>
                <span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">,</span>
                <span class="n">y</span><span class="o">=</span><span class="n">y_</span><span class="p">,</span>
                <span class="n">sample_weight</span><span class="o">=</span><span class="n">sample_weight_</span><span class="p">,</span>  <span class="c1"># type: ignore</span>
                <span class="n">group</span><span class="o">=</span><span class="n">group_</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Use standard fit for pandas/numpy</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">booster</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
                <span class="n">flat_data</span><span class="o">=</span><span class="n">flat_data</span><span class="p">,</span>
                <span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">,</span>
                <span class="n">cols</span><span class="o">=</span><span class="n">cols</span><span class="p">,</span>
                <span class="n">y</span><span class="o">=</span><span class="n">y_</span><span class="p">,</span>
                <span class="n">sample_weight</span><span class="o">=</span><span class="n">sample_weight_</span><span class="p">,</span>  <span class="c1"># type: ignore</span>
                <span class="n">group</span><span class="o">=</span><span class="n">group_</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="PerpetualBooster.prune">
<a class="viewcode-back" href="../../generated/perpetual.PerpetualBooster.html#perpetual.PerpetualBooster.prune">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">prune</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prune the gradient booster on a provided dataset.</span>

<span class="sd">        This removes nodes that do not contribute to a reduction in loss on the provided</span>
<span class="sd">        validation set.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : array-like of shape (n_samples, n_features)</span>
<span class="sd">            Validation data.</span>
<span class="sd">        y : array-like of shape (n_samples,)</span>
<span class="sd">            Validation targets.</span>
<span class="sd">        sample_weight : array-like of shape (n_samples,), optional</span>
<span class="sd">            Weights for validation samples.</span>
<span class="sd">        group : array-like, optional</span>
<span class="sd">            Group labels for ranking objectives.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : object</span>
<span class="sd">            Returns self.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">flat_data</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">transform_input_frame</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cat_mapping</span><span class="p">)</span>

        <span class="n">y_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">convert_input_array</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">objective</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sample_weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sample_weight_</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sample_weight_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">convert_input_array</span><span class="p">(</span><span class="n">sample_weight</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">objective</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">group</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">group_</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">group_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">convert_input_array</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">objective</span><span class="p">,</span> <span class="n">is_int</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">booster</span><span class="o">.</span><span class="n">prune</span><span class="p">(</span>
            <span class="n">flat_data</span><span class="o">=</span><span class="n">flat_data</span><span class="p">,</span>
            <span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">,</span>
            <span class="n">cols</span><span class="o">=</span><span class="n">cols</span><span class="p">,</span>
            <span class="n">y</span><span class="o">=</span><span class="n">y_</span><span class="p">,</span>
            <span class="n">sample_weight</span><span class="o">=</span><span class="n">sample_weight_</span><span class="p">,</span>  <span class="c1"># type: ignore</span>
            <span class="n">group</span><span class="o">=</span><span class="n">group_</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="PerpetualBooster.calibrate">
<a class="viewcode-back" href="../../generated/perpetual.PerpetualBooster.html#perpetual.PerpetualBooster.calibrate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">calibrate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_cal</span><span class="p">,</span> <span class="n">y_cal</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calibrate the gradient booster for prediction intervals.</span>

<span class="sd">        Uses the provided training and calibration sets to compute scaling factors</span>
<span class="sd">        for intervals.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X_train : array-like</span>
<span class="sd">            Data used to train the base model.</span>
<span class="sd">        y_train : array-like</span>
<span class="sd">            Targets for training data.</span>
<span class="sd">        X_cal : array-like</span>
<span class="sd">            Independent calibration dataset.</span>
<span class="sd">        y_cal : array-like</span>
<span class="sd">            Targets for calibration data.</span>
<span class="sd">        alpha : float or array-like</span>
<span class="sd">            Significance level(s) for the intervals (1 - coverage).</span>
<span class="sd">        sample_weight : array-like, optional</span>
<span class="sd">            Sample weights.</span>
<span class="sd">        group : array-like, optional</span>
<span class="sd">            Group labels.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : object</span>
<span class="sd">            Returns self.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">is_polars</span> <span class="o">=</span> <span class="n">type_df</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;polars_df&quot;</span>
        <span class="k">if</span> <span class="n">is_polars</span><span class="p">:</span>
            <span class="n">features_train</span><span class="p">,</span> <span class="n">cols_train</span><span class="p">,</span> <span class="n">masks_train</span><span class="p">,</span> <span class="n">rows_train</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">transform_input_frame_columnar</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cat_mapping</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_validate_features</span><span class="p">(</span><span class="n">features_train</span><span class="p">)</span>
            <span class="n">features_cal</span><span class="p">,</span> <span class="n">cols_cal</span><span class="p">,</span> <span class="n">masks_cal</span><span class="p">,</span> <span class="n">rows_cal</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">transform_input_frame_columnar</span><span class="p">(</span><span class="n">X_cal</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cat_mapping</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="c1"># Use columnar calibration</span>
            <span class="n">y_train_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">convert_input_array</span><span class="p">(</span><span class="n">y_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">objective</span><span class="p">)</span>
            <span class="n">y_cal_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">convert_input_array</span><span class="p">(</span><span class="n">y_cal</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">objective</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sample_weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sample_weight_</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sample_weight_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">convert_input_array</span><span class="p">(</span><span class="n">sample_weight</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">objective</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">booster</span><span class="o">.</span><span class="n">calibrate_columnar</span><span class="p">(</span>
                <span class="n">columns</span><span class="o">=</span><span class="n">cols_train</span><span class="p">,</span>
                <span class="n">masks</span><span class="o">=</span><span class="n">masks_train</span><span class="p">,</span>
                <span class="n">rows</span><span class="o">=</span><span class="n">rows_train</span><span class="p">,</span>
                <span class="n">y</span><span class="o">=</span><span class="n">y_train_</span><span class="p">,</span>
                <span class="n">columns_cal</span><span class="o">=</span><span class="n">cols_cal</span><span class="p">,</span>
                <span class="n">masks_cal</span><span class="o">=</span><span class="n">masks_cal</span><span class="p">,</span>
                <span class="n">rows_cal</span><span class="o">=</span><span class="n">rows_cal</span><span class="p">,</span>
                <span class="n">y_cal</span><span class="o">=</span><span class="n">y_cal_</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">alpha</span><span class="p">),</span>
                <span class="n">sample_weight</span><span class="o">=</span><span class="n">sample_weight_</span><span class="p">,</span>  <span class="c1"># type: ignore</span>
                <span class="n">group</span><span class="o">=</span><span class="n">group</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">flat_data_train</span><span class="p">,</span> <span class="n">rows_train</span><span class="p">,</span> <span class="n">cols_train</span> <span class="o">=</span> <span class="n">transform_input_frame</span><span class="p">(</span>
                <span class="n">X_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cat_mapping</span>
            <span class="p">)</span>

            <span class="n">y_train_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">convert_input_array</span><span class="p">(</span><span class="n">y_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">objective</span><span class="p">)</span>

            <span class="n">_</span><span class="p">,</span> <span class="n">flat_data_cal</span><span class="p">,</span> <span class="n">rows_cal</span><span class="p">,</span> <span class="n">cols_cal</span> <span class="o">=</span> <span class="n">transform_input_frame</span><span class="p">(</span>
                <span class="n">X_cal</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cat_mapping</span>
            <span class="p">)</span>

            <span class="n">y_cal_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">convert_input_array</span><span class="p">(</span><span class="n">y_cal</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">objective</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">sample_weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sample_weight_</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sample_weight_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">convert_input_array</span><span class="p">(</span><span class="n">sample_weight</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">objective</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">booster</span><span class="o">.</span><span class="n">calibrate</span><span class="p">(</span>
                <span class="n">flat_data</span><span class="o">=</span><span class="n">flat_data_train</span><span class="p">,</span>
                <span class="n">rows</span><span class="o">=</span><span class="n">rows_train</span><span class="p">,</span>
                <span class="n">cols</span><span class="o">=</span><span class="n">cols_train</span><span class="p">,</span>
                <span class="n">y</span><span class="o">=</span><span class="n">y_train_</span><span class="p">,</span>
                <span class="n">flat_data_cal</span><span class="o">=</span><span class="n">flat_data_cal</span><span class="p">,</span>
                <span class="n">rows_cal</span><span class="o">=</span><span class="n">rows_cal</span><span class="p">,</span>
                <span class="n">cols_cal</span><span class="o">=</span><span class="n">cols_cal</span><span class="p">,</span>
                <span class="n">y_cal</span><span class="o">=</span><span class="n">y_cal_</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">alpha</span><span class="p">),</span>
                <span class="n">sample_weight</span><span class="o">=</span><span class="n">sample_weight_</span><span class="p">,</span>  <span class="c1"># type: ignore</span>
                <span class="n">group</span><span class="o">=</span><span class="n">group</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_validate_features</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">features</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">features</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;feature_names_in_&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">features</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;0&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_names_in_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;0&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">features</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_names_in_</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Columns mismatch between data </span><span class="si">{</span><span class="n">features</span><span class="si">}</span><span class="s2"> passed, and data </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">feature_names_in_</span><span class="si">}</span><span class="s2"> used at fit.&quot;</span>
                    <span class="p">)</span>

<div class="viewcode-block" id="PerpetualBooster.predict_intervals">
<a class="viewcode-back" href="../../generated/perpetual.PerpetualBooster.html#perpetual.PerpetualBooster.predict_intervals">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">predict_intervals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">parallel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Predict intervals with the fitted booster on new data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : array-like of shape (n_samples, n_features)</span>
<span class="sd">            New data for prediction.</span>
<span class="sd">        parallel : bool, optional</span>
<span class="sd">            Whether to run prediction in parallel. If None, uses class default.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        intervals : dict</span>
<span class="sd">            A dictionary containing lower and upper bounds for the specified alpha levels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">is_polars</span> <span class="o">=</span> <span class="n">type_df</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;polars_df&quot;</span>
        <span class="k">if</span> <span class="n">is_polars</span><span class="p">:</span>
            <span class="n">features_</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">masks</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">transform_input_frame_columnar</span><span class="p">(</span>
                <span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cat_mapping</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_validate_features</span><span class="p">(</span><span class="n">features_</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">booster</span><span class="o">.</span><span class="n">predict_intervals_columnar</span><span class="p">(</span>
                <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span> <span class="n">masks</span><span class="o">=</span><span class="n">masks</span><span class="p">,</span> <span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span>
            <span class="p">)</span>

        <span class="n">features_</span><span class="p">,</span> <span class="n">flat_data</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">transform_input_frame</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cat_mapping</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_features</span><span class="p">(</span><span class="n">features_</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">booster</span><span class="o">.</span><span class="n">predict_intervals</span><span class="p">(</span>
            <span class="n">flat_data</span><span class="o">=</span><span class="n">flat_data</span><span class="p">,</span>
            <span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">,</span>
            <span class="n">cols</span><span class="o">=</span><span class="n">cols</span><span class="p">,</span>
            <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="PerpetualBooster.predict">
<a class="viewcode-back" href="../../generated/perpetual.PerpetualBooster.html#perpetual.PerpetualBooster.predict">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">parallel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Predict with the fitted booster on new data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : array-like of shape (n_samples, n_features)</span>
<span class="sd">            Input features.</span>
<span class="sd">        parallel : bool, optional</span>
<span class="sd">            Whether to run prediction in parallel.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        predictions : ndarray of shape (n_samples,)</span>
<span class="sd">            The predicted values (log-odds for classification, raw values for regression).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">is_polars</span> <span class="o">=</span> <span class="n">type_df</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;polars_df&quot;</span>
        <span class="k">if</span> <span class="n">is_polars</span><span class="p">:</span>
            <span class="n">features_</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">masks</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">transform_input_frame_columnar</span><span class="p">(</span>
                <span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cat_mapping</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">features_</span><span class="p">,</span> <span class="n">flat_data</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">transform_input_frame</span><span class="p">(</span>
                <span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cat_mapping</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_features</span><span class="p">(</span><span class="n">features_</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">classes_</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_polars</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">booster</span><span class="o">.</span><span class="n">predict_columnar</span><span class="p">(</span>
                    <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span> <span class="n">masks</span><span class="o">=</span><span class="n">masks</span><span class="p">,</span> <span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">booster</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span>
                <span class="n">flat_data</span><span class="o">=</span><span class="n">flat_data</span><span class="p">,</span> <span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="o">=</span><span class="n">cols</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">classes_</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_polars</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">booster</span><span class="o">.</span><span class="n">predict_proba_columnar</span><span class="p">(</span>
                        <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span> <span class="n">masks</span><span class="o">=</span><span class="n">masks</span><span class="p">,</span> <span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span>
                    <span class="p">)</span>
                <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">booster</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span>
                    <span class="n">flat_data</span><span class="o">=</span><span class="n">flat_data</span><span class="p">,</span> <span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="o">=</span><span class="n">cols</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span>
                <span class="p">)</span>
            <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_polars</span><span class="p">:</span>
                <span class="n">preds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">booster</span><span class="o">.</span><span class="n">predict_columnar</span><span class="p">(</span>
                    <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span> <span class="n">masks</span><span class="o">=</span><span class="n">masks</span><span class="p">,</span> <span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">preds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">booster</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span>
                    <span class="n">flat_data</span><span class="o">=</span><span class="n">flat_data</span><span class="p">,</span> <span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="o">=</span><span class="n">cols</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span>
                <span class="p">)</span>
            <span class="n">preds_matrix</span> <span class="o">=</span> <span class="n">preds</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">classes_</span><span class="p">)),</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;F&quot;</span><span class="p">)</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">preds_matrix</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">classes_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">])</span></div>


<div class="viewcode-block" id="PerpetualBooster.predict_proba">
<a class="viewcode-back" href="../../generated/perpetual.PerpetualBooster.html#perpetual.PerpetualBooster.predict_proba">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">predict_proba</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">parallel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Predict class probabilities with the fitted booster on new data.</span>

<span class="sd">        Only valid for classification tasks.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : array-like of shape (n_samples, n_features)</span>
<span class="sd">            Input features.</span>
<span class="sd">        parallel : bool, optional</span>
<span class="sd">            Whether to run prediction in parallel.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        probabilities : ndarray of shape (n_samples, n_classes)</span>
<span class="sd">            The class probabilities.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">is_polars</span> <span class="o">=</span> <span class="n">type_df</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;polars_df&quot;</span>
        <span class="k">if</span> <span class="n">is_polars</span><span class="p">:</span>
            <span class="n">features_</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">masks</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">transform_input_frame_columnar</span><span class="p">(</span>
                <span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cat_mapping</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">features_</span><span class="p">,</span> <span class="n">flat_data</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">transform_input_frame</span><span class="p">(</span>
                <span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cat_mapping</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_features</span><span class="p">(</span><span class="n">features_</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">classes_</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_polars</span><span class="p">:</span>
                <span class="n">probabilities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">booster</span><span class="o">.</span><span class="n">predict_proba_columnar</span><span class="p">(</span>
                    <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span> <span class="n">masks</span><span class="o">=</span><span class="n">masks</span><span class="p">,</span> <span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">probabilities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">booster</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span>
                    <span class="n">flat_data</span><span class="o">=</span><span class="n">flat_data</span><span class="p">,</span> <span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="o">=</span><span class="n">cols</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">probabilities</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">classes_</span><span class="p">)),</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">classes_</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_polars</span><span class="p">:</span>
                <span class="n">probabilities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">booster</span><span class="o">.</span><span class="n">predict_proba_columnar</span><span class="p">(</span>
                    <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span> <span class="n">masks</span><span class="o">=</span><span class="n">masks</span><span class="p">,</span> <span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">probabilities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">booster</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span>
                    <span class="n">flat_data</span><span class="o">=</span><span class="n">flat_data</span><span class="p">,</span> <span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="o">=</span><span class="n">cols</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">[(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">probabilities</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">probabilities</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;predict_proba not implemented for regression. n_classes = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">classes_</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">rows</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span></div>


<div class="viewcode-block" id="PerpetualBooster.predict_log_proba">
<a class="viewcode-back" href="../../generated/perpetual.PerpetualBooster.html#perpetual.PerpetualBooster.predict_log_proba">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">predict_log_proba</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">parallel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Predict class log-probabilities with the fitted booster on new data.</span>

<span class="sd">        Only valid for classification tasks.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : array-like of shape (n_samples, n_features)</span>
<span class="sd">            Input features.</span>
<span class="sd">        parallel : bool, optional</span>
<span class="sd">            Whether to run prediction in parallel.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        log_probabilities : ndarray of shape (n_samples, n_classes)</span>
<span class="sd">            The log-probabilities of each class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">is_polars</span> <span class="o">=</span> <span class="n">type_df</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;polars_df&quot;</span>
        <span class="k">if</span> <span class="n">is_polars</span><span class="p">:</span>
            <span class="n">features_</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">masks</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">transform_input_frame_columnar</span><span class="p">(</span>
                <span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cat_mapping</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">features_</span><span class="p">,</span> <span class="n">flat_data</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">transform_input_frame</span><span class="p">(</span>
                <span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cat_mapping</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_features</span><span class="p">(</span><span class="n">features_</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">classes_</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_polars</span><span class="p">:</span>
                <span class="n">preds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">booster</span><span class="o">.</span><span class="n">predict_columnar</span><span class="p">(</span>
                    <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span> <span class="n">masks</span><span class="o">=</span><span class="n">masks</span><span class="p">,</span> <span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">preds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">booster</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span>
                    <span class="n">flat_data</span><span class="o">=</span><span class="n">flat_data</span><span class="p">,</span>
                    <span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">,</span>
                    <span class="n">cols</span><span class="o">=</span><span class="n">cols</span><span class="p">,</span>
                    <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">preds</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">classes_</span><span class="p">)),</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;F&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">classes_</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_polars</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">booster</span><span class="o">.</span><span class="n">predict_columnar</span><span class="p">(</span>
                    <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span> <span class="n">masks</span><span class="o">=</span><span class="n">masks</span><span class="p">,</span> <span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">booster</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span>
                <span class="n">flat_data</span><span class="o">=</span><span class="n">flat_data</span><span class="p">,</span>
                <span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">,</span>
                <span class="n">cols</span><span class="o">=</span><span class="n">cols</span><span class="p">,</span>
                <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;predict_log_proba not implemented for regression.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">rows</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span></div>


<div class="viewcode-block" id="PerpetualBooster.predict_nodes">
<a class="viewcode-back" href="../../generated/perpetual.PerpetualBooster.html#perpetual.PerpetualBooster.predict_nodes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">predict_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">parallel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Predict leaf node indices with the fitted booster on new data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : array-like of shape (n_samples, n_features)</span>
<span class="sd">            Input features.</span>
<span class="sd">        parallel : bool, optional</span>
<span class="sd">            Whether to run prediction in parallel.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        node_indices : list of ndarray</span>
<span class="sd">            A list where each element corresponds to a tree and contains node indices</span>
<span class="sd">            for each sample.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">is_polars</span> <span class="o">=</span> <span class="n">type_df</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;polars_df&quot;</span>
        <span class="k">if</span> <span class="n">is_polars</span><span class="p">:</span>
            <span class="n">features_</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">masks</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">transform_input_frame_columnar</span><span class="p">(</span>
                <span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cat_mapping</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_validate_features</span><span class="p">(</span><span class="n">features_</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">booster</span><span class="o">.</span><span class="n">predict_nodes_columnar</span><span class="p">(</span>
                <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span> <span class="n">masks</span><span class="o">=</span><span class="n">masks</span><span class="p">,</span> <span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span>
            <span class="p">)</span>

        <span class="n">features_</span><span class="p">,</span> <span class="n">flat_data</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">transform_input_frame</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cat_mapping</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_features</span><span class="p">(</span><span class="n">features_</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">booster</span><span class="o">.</span><span class="n">predict_nodes</span><span class="p">(</span>
            <span class="n">flat_data</span><span class="o">=</span><span class="n">flat_data</span><span class="p">,</span> <span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="o">=</span><span class="n">cols</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span>
        <span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">feature_importances_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_feature_importance</span><span class="p">(</span>
            <span class="n">method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">feature_importance_method</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;feature_names_in_&quot;</span><span class="p">):</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">vals</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">vals</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ft</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span> <span class="k">for</span> <span class="n">ft</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_names_in_</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">vals</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">vals</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ft</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span> <span class="k">for</span> <span class="n">ft</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_features_</span><span class="p">)])</span>

<div class="viewcode-block" id="PerpetualBooster.predict_contributions">
<a class="viewcode-back" href="../../generated/perpetual.PerpetualBooster.html#perpetual.PerpetualBooster.predict_contributions">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">predict_contributions</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Average&quot;</span><span class="p">,</span> <span class="n">parallel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Predict feature contributions (SHAP-like values) for new data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : array-like of shape (n_samples, n_features)</span>
<span class="sd">            Input features.</span>
<span class="sd">        method : str, default=&quot;Average&quot;</span>
<span class="sd">            Method to calculate contributions. Options:</span>

<span class="sd">            - &quot;Average&quot;: Internal node averages.</span>
<span class="sd">            - &quot;Shapley&quot;: Exact tree SHAP values.</span>
<span class="sd">            - &quot;Weight&quot;: Saabas-style leaf weights.</span>
<span class="sd">            - &quot;BranchDifference&quot;: Difference between chosen and other branch.</span>
<span class="sd">            - &quot;MidpointDifference&quot;: Weighted difference between branches.</span>
<span class="sd">            - &quot;ModeDifference&quot;: Difference from the most frequent node.</span>
<span class="sd">            - &quot;ProbabilityChange&quot;: Change in probability (LogLoss only).</span>

<span class="sd">        parallel : bool, optional</span>
<span class="sd">            Whether to run prediction in parallel.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        contributions : ndarray of shape (n_samples, n_features + 1)</span>
<span class="sd">            The contribution of each feature to the prediction. The last column</span>
<span class="sd">            is the bias term.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">is_polars</span> <span class="o">=</span> <span class="n">type_df</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;polars_df&quot;</span>
        <span class="k">if</span> <span class="n">is_polars</span><span class="p">:</span>
            <span class="n">features_</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">masks</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">transform_input_frame_columnar</span><span class="p">(</span>
                <span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cat_mapping</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_validate_features</span><span class="p">(</span><span class="n">features_</span><span class="p">)</span>
            <span class="n">contributions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">booster</span><span class="o">.</span><span class="n">predict_contributions_columnar</span><span class="p">(</span>
                <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
                <span class="n">masks</span><span class="o">=</span><span class="n">masks</span><span class="p">,</span>
                <span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="n">CONTRIBUTION_METHODS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">method</span><span class="p">),</span>
                <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">features_</span><span class="p">,</span> <span class="n">flat_data</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">transform_input_frame</span><span class="p">(</span>
                <span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cat_mapping</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_validate_features</span><span class="p">(</span><span class="n">features_</span><span class="p">)</span>

            <span class="n">contributions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">booster</span><span class="o">.</span><span class="n">predict_contributions</span><span class="p">(</span>
                <span class="n">flat_data</span><span class="o">=</span><span class="n">flat_data</span><span class="p">,</span>
                <span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">,</span>
                <span class="n">cols</span><span class="o">=</span><span class="n">cols</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="n">CONTRIBUTION_METHODS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">method</span><span class="p">),</span>
                <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">classes_</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">contributions</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">classes_</span><span class="p">),</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                <span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                <span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">contributions</span><span class="p">,</span> <span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span></div>


<div class="viewcode-block" id="PerpetualBooster.partial_dependence">
<a class="viewcode-back" href="../../generated/perpetual.PerpetualBooster.html#perpetual.PerpetualBooster.partial_dependence">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">partial_dependence</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">X</span><span class="p">,</span>
        <span class="n">feature</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">samples</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">exclude_missing</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">percentile_bounds</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.98</span><span class="p">),</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the partial dependence values of a feature.</span>

<span class="sd">        For each unique value of the feature, this gives the estimate of the predicted</span>
<span class="sd">        value for that feature, with the effects of all other features averaged out.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : array-like</span>
<span class="sd">            Data used to calculate partial dependence. Should be the same format</span>
<span class="sd">            as passed to :meth:`fit`.</span>
<span class="sd">        feature : str or int</span>
<span class="sd">            The feature for which to calculate partial dependence.</span>
<span class="sd">        samples : int, optional, default=100</span>
<span class="sd">            Number of evenly spaced samples to select. If None, all unique values are used.</span>
<span class="sd">        exclude_missing : bool, optional, default=True</span>
<span class="sd">            Whether to exclude missing values from the calculation.</span>
<span class="sd">        percentile_bounds : tuple of float, optional, default=(0.2, 0.98)</span>
<span class="sd">            Lower and upper percentiles for sample selection.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd_values : ndarray of shape (n_samples, 2)</span>
<span class="sd">            The first column contains the feature values, and the second column</span>
<span class="sd">            contains the partial dependence values.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        &gt;&gt;&gt; pd_values = model.partial_dependence(X, feature=&quot;age&quot;)</span>
<span class="sd">        &gt;&gt;&gt; plt.plot(pd_values[:, 0], pd_values[:, 1])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">feature</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">is_polars</span> <span class="o">=</span> <span class="n">type_df</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;polars_df&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">type_df</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;pandas_df&quot;</span> <span class="ow">or</span> <span class="n">is_polars</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;If `feature` is a string, then the object passed as `X` must be a pandas or polars DataFrame.&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">is_polars</span><span class="p">:</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">feature</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">feature</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;feature_names_in_&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_names_in_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;0&quot;</span><span class="p">:</span>
                <span class="p">[</span><span class="n">feature_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">feature_names_in_</span><span class="p">)</span> <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">feature</span>
                <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">w_msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;No feature names were provided at fit, but feature was a string, attempting to &quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;determine feature index from DataFrame Column, &quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;ensure columns are the same order as data passed when fit.&quot;</span>
                <span class="p">)</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">w_msg</span><span class="p">)</span>
                <span class="n">features</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">is_polars</span> <span class="k">else</span> <span class="n">X</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
                <span class="p">[</span><span class="n">feature_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">features</span><span class="p">)</span> <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">feature</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">feature</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">feature_idx</span> <span class="o">=</span> <span class="n">feature</span>
            <span class="k">if</span> <span class="n">type_df</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;pandas_df&quot;</span><span class="p">:</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()[:,</span> <span class="n">feature</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">type_df</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;polars_df&quot;</span><span class="p">:</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">allow_copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)[:,</span> <span class="n">feature</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="n">feature</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The parameter `feature` must be a string, or an int, however an object of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">feature</span><span class="p">)</span><span class="si">}</span><span class="s2"> was passed.&quot;</span>
            <span class="p">)</span>
        <span class="n">min_p</span><span class="p">,</span> <span class="n">max_p</span> <span class="o">=</span> <span class="n">percentile_bounds</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="o">~</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">values</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing</span><span class="p">))]</span>
        <span class="k">if</span> <span class="n">samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">search_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Exclude missing from this calculation.</span>
            <span class="n">search_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">min_p</span><span class="p">,</span> <span class="n">max_p</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">samples</span><span class="p">))</span>

        <span class="c1"># Add missing back, if they wanted it...</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">exclude_missing</span><span class="p">:</span>
            <span class="n">search_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">missing</span><span class="p">],</span> <span class="n">search_values</span><span class="p">)</span>

        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">search_values</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">booster</span><span class="o">.</span><span class="n">value_partial_dependence</span><span class="p">(</span><span class="n">feature</span><span class="o">=</span><span class="n">feature_idx</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">v</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">res</span><span class="p">)</span></div>


<div class="viewcode-block" id="PerpetualBooster.calculate_feature_importance">
<a class="viewcode-back" href="../../generated/perpetual.PerpetualBooster.html#perpetual.PerpetualBooster.calculate_feature_importance">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_feature_importance</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Gain&quot;</span><span class="p">,</span> <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate feature importance for the model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : str, optional, default=&quot;Gain&quot;</span>
<span class="sd">            Importance method. Options:</span>

<span class="sd">            - &quot;Weight&quot;: Number of times a feature is used in splits.</span>
<span class="sd">            - &quot;Gain&quot;: Average improvement in loss brought by a feature.</span>
<span class="sd">            - &quot;Cover&quot;: Average number of samples affected by splits on a feature.</span>
<span class="sd">            - &quot;TotalGain&quot;: Total improvement in loss brought by a feature.</span>
<span class="sd">            - &quot;TotalCover&quot;: Total number of samples affected by splits on a feature.</span>

<span class="sd">        normalize : bool, optional, default=True</span>
<span class="sd">            Whether to normalize importance scores to sum to 1.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        importance : dict</span>
<span class="sd">            A dictionary mapping feature names (or indices) to importance scores.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">importance_</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">booster</span><span class="o">.</span><span class="n">calculate_feature_importance</span><span class="p">(</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;feature_names_in_&quot;</span><span class="p">):</span>
            <span class="n">feature_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">i</span><span class="p">:</span> <span class="n">f</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">feature_names_in_</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">feature_map</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">importance_</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">return</span> <span class="n">importance_</span></div>


<div class="viewcode-block" id="PerpetualBooster.text_dump">
<a class="viewcode-back" href="../../generated/perpetual.PerpetualBooster.html#perpetual.PerpetualBooster.text_dump">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">text_dump</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the booster model in a human-readable text format.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dump : list of str</span>
<span class="sd">            A list where each string represents a tree in the ensemble.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">booster</span><span class="o">.</span><span class="n">text_dump</span><span class="p">()</span></div>


<div class="viewcode-block" id="PerpetualBooster.json_dump">
<a class="viewcode-back" href="../../generated/perpetual.PerpetualBooster.html#perpetual.PerpetualBooster.json_dump">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">json_dump</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the booster model in JSON format.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dump : str</span>
<span class="sd">            The JSON representation of the model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">booster</span><span class="o">.</span><span class="n">json_dump</span><span class="p">()</span></div>


<div class="viewcode-block" id="PerpetualBooster.load_booster">
<a class="viewcode-back" href="../../generated/perpetual.PerpetualBooster.html#perpetual.PerpetualBooster.load_booster">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_booster</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load a booster model from a file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : str</span>
<span class="sd">            Path to the saved booster (JSON format).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        model : PerpetualBooster</span>
<span class="sd">            The loaded booster object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">booster</span> <span class="o">=</span> <span class="n">CratePerpetualBooster</span><span class="o">.</span><span class="n">load_booster</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">booster</span> <span class="o">=</span> <span class="n">CrateMultiOutputBooster</span><span class="o">.</span><span class="n">load_booster</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>

        <span class="n">params</span> <span class="o">=</span> <span class="n">booster</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
            <span class="n">c</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>
        <span class="n">c</span><span class="o">.</span><span class="n">booster</span> <span class="o">=</span> <span class="n">booster</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">metadata_attributes</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">m_</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">_get_metadata_attributes</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">m_</span><span class="p">)</span>
                <span class="c1"># If &quot;feature_names_in_&quot; is present, we know a</span>
                <span class="c1"># pandas dataframe was used for fitting, in this case</span>
                <span class="c1"># get back the original monotonicity map, with the</span>
                <span class="c1"># feature names as keys.</span>
                <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="s2">&quot;feature_names_in_&quot;</span> <span class="ow">and</span> <span class="n">c</span><span class="o">.</span><span class="n">feature_names_in_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;0&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">monotone_constraints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">c</span><span class="o">.</span><span class="n">monotone_constraints</span> <span class="o">=</span> <span class="p">{</span>
                            <span class="n">ft</span><span class="p">:</span> <span class="n">c</span><span class="o">.</span><span class="n">monotone_constraints</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ft</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">feature_names_in_</span><span class="p">)</span>
                        <span class="p">}</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">return</span> <span class="n">c</span></div>


<div class="viewcode-block" id="PerpetualBooster.save_booster">
<a class="viewcode-back" href="../../generated/perpetual.PerpetualBooster.html#perpetual.PerpetualBooster.save_booster">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">save_booster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the booster model to a file.</span>

<span class="sd">        The model is saved in a JSON-based format.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : str</span>
<span class="sd">            Path where the model will be saved.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">booster</span><span class="o">.</span><span class="n">save_booster</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">path</span><span class="p">))</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_standardize_monotonicity_map</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">X</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">monotone_constraints</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">feature_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">f</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">columns</span><span class="p">)}</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">feature_map</span><span class="p">[</span><span class="n">f</span><span class="p">]:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">monotone_constraints</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_standardize_terminate_missing_features</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">X</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">terminate_missing_features</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">feature_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">f</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">columns</span><span class="p">)}</span>
            <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">feature_map</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">terminate_missing_features</span><span class="p">)</span>

<div class="viewcode-block" id="PerpetualBooster.insert_metadata">
<a class="viewcode-back" href="../../generated/perpetual.PerpetualBooster.html#perpetual.PerpetualBooster.insert_metadata">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">insert_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Insert metadata into the model.</span>

<span class="sd">        Metadata is saved alongside the model and can be retrieved later.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : str</span>
<span class="sd">            The key for the metadata item.</span>
<span class="sd">        value : str</span>
<span class="sd">            The value for the metadata item.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">booster</span><span class="o">.</span><span class="n">insert_metadata</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">)</span></div>


<div class="viewcode-block" id="PerpetualBooster.get_metadata">
<a class="viewcode-back" href="../../generated/perpetual.PerpetualBooster.html#perpetual.PerpetualBooster.get_metadata">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get metadata associated with a given key.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : str</span>
<span class="sd">            The key to look up in the metadata.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        value : str</span>
<span class="sd">            The value associated with the key.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">booster</span><span class="o">.</span><span class="n">get_metadata</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">v</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_set_metadata_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">value_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_attributes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">serialize</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">insert_metadata</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value_</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_metadata_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_metadata</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_attributes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">deserialize</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">base_score</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The base score(s) of the model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        score : float or iterable of float</span>
<span class="sd">            The initial prediction value(s) of the model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">booster</span><span class="o">.</span><span class="n">base_score</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">number_of_trees</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of trees in the ensemble.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        n_trees : int or iterable of int</span>
<span class="sd">            Total number of trees.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">booster</span><span class="o">.</span><span class="n">number_of_trees</span>

    <span class="c1"># Make picklable with getstate and setstate</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="n">booster_json</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">json_dump</span><span class="p">()</span>
        <span class="c1"># Delete booster</span>
        <span class="c1"># Doing it like this, so it doesn&#39;t delete it globally.</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="s2">&quot;booster&quot;</span><span class="p">}</span>
        <span class="n">res</span><span class="p">[</span><span class="s2">&quot;__booster_json_file__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">booster_json</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Load the booster object the pickled JSon string.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">booster_object</span> <span class="o">=</span> <span class="n">CratePerpetualBooster</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;__booster_json_file__&quot;</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">booster_object</span> <span class="o">=</span> <span class="n">CrateMultiOutputBooster</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span>
                <span class="n">d</span><span class="p">[</span><span class="s2">&quot;__booster_json_file__&quot;</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;booster&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">booster_object</span>
        <span class="c1"># Are there any new parameters, that need to be added to the python object,</span>
        <span class="c1"># that would have been loaded in as defaults on the json object?</span>
        <span class="c1"># This makes sure that defaults set with a serde default function get</span>
        <span class="c1"># carried through to the python object.</span>
        <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">booster_object</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">p</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">del</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;__booster_json_file__&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="n">d</span>

    <span class="c1"># Functions for scikit-learn compatibility, will feel out adding these manually,</span>
    <span class="c1"># and then if that feels too unwieldy will add scikit-learn as a dependency.</span>
<div class="viewcode-block" id="PerpetualBooster.get_params">
<a class="viewcode-back" href="../../generated/perpetual.PerpetualBooster.html#perpetual.PerpetualBooster.get_params">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get parameters for this booster.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        deep : bool, default=True</span>
<span class="sd">            Currently ignored, exists for scikit-learn compatibility.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        params : dict</span>
<span class="sd">            Parameter names mapped to their values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getfullargspec</span><span class="p">(</span><span class="n">PerpetualBooster</span><span class="p">)</span><span class="o">.</span><span class="n">kwonlyargs</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">param</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">args</span><span class="p">}</span></div>


<div class="viewcode-block" id="PerpetualBooster.set_params">
<a class="viewcode-back" href="../../generated/perpetual.PerpetualBooster.html#perpetual.PerpetualBooster.set_params">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set parameters for this booster.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **params : dict</span>
<span class="sd">            Booster parameters.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : object</span>
<span class="sd">            Returns self.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">old_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span>
        <span class="n">old_params</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="n">PerpetualBooster</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">old_params</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="PerpetualBooster.get_node_lists">
<a class="viewcode-back" href="../../generated/perpetual.PerpetualBooster.html#perpetual.PerpetualBooster.get_node_lists">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_node_lists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">map_features_names</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Node</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return tree structures as lists of node objects.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        map_features_names : bool, default=True</span>
<span class="sd">            Whether to use feature names instead of indices.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        trees : list of list of Node</span>
<span class="sd">            Each inner list represents a tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dump</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">json_dump</span><span class="p">())</span>
        <span class="k">if</span> <span class="s2">&quot;trees&quot;</span> <span class="ow">in</span> <span class="n">dump</span><span class="p">:</span>
            <span class="n">all_booster_trees</span> <span class="o">=</span> <span class="p">[</span><span class="n">dump</span><span class="p">[</span><span class="s2">&quot;trees&quot;</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Multi-output</span>
            <span class="n">all_booster_trees</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="s2">&quot;trees&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">dump</span><span class="p">[</span><span class="s2">&quot;boosters&quot;</span><span class="p">]]</span>

        <span class="n">feature_map</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span>
        <span class="n">leaf_split_feature</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">map_features_names</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;feature_names_in_&quot;</span><span class="p">):</span>
            <span class="n">feature_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">ft</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ft</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">feature_names_in_</span><span class="p">)}</span>
            <span class="n">leaf_split_feature</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">feature_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_features_</span><span class="p">)}</span>
            <span class="n">leaf_split_feature</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="n">trees</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">booster_trees</span> <span class="ow">in</span> <span class="n">all_booster_trees</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">booster_trees</span><span class="p">:</span>
                <span class="n">nodes</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t</span><span class="p">[</span><span class="s2">&quot;nodes&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">[</span><span class="s2">&quot;is_leaf&quot;</span><span class="p">]:</span>
                        <span class="n">node</span><span class="p">[</span><span class="s2">&quot;split_feature&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">feature_map</span><span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="s2">&quot;split_feature&quot;</span><span class="p">]]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">node</span><span class="p">[</span><span class="s2">&quot;split_feature&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">leaf_split_feature</span>
                    <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="p">(</span><span class="o">**</span><span class="n">node</span><span class="p">))</span>
                <span class="n">trees</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">trees</span></div>


<div class="viewcode-block" id="PerpetualBooster.trees_to_dataframe">
<a class="viewcode-back" href="../../generated/perpetual.PerpetualBooster.html#perpetual.PerpetualBooster.trees_to_dataframe">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">trees_to_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the tree structures as a DataFrame.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        df : DataFrame</span>
<span class="sd">            A Polars or Pandas DataFrame containing tree information.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">node_to_row</span><span class="p">(</span>
            <span class="n">n</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
            <span class="n">tree_n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">_id</span><span class="p">(</span><span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
                <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tree_n</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span>

            <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="n">Tree</span><span class="o">=</span><span class="n">tree_n</span><span class="p">,</span>
                <span class="n">Node</span><span class="o">=</span><span class="n">n</span><span class="o">.</span><span class="n">num</span><span class="p">,</span>
                <span class="n">ID</span><span class="o">=</span><span class="n">_id</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">num</span><span class="p">),</span>
                <span class="n">Feature</span><span class="o">=</span><span class="s2">&quot;Leaf&quot;</span> <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">is_leaf</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">split_feature</span><span class="p">),</span>
                <span class="n">Split</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">is_leaf</span> <span class="k">else</span> <span class="n">n</span><span class="o">.</span><span class="n">split_value</span><span class="p">,</span>
                <span class="n">Yes</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">is_leaf</span> <span class="k">else</span> <span class="n">_id</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">left_child</span><span class="p">),</span>
                <span class="n">No</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">is_leaf</span> <span class="k">else</span> <span class="n">_id</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">right_child</span><span class="p">),</span>
                <span class="n">Missing</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">is_leaf</span> <span class="k">else</span> <span class="n">_id</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">missing_node</span><span class="p">),</span>
                <span class="n">Gain</span><span class="o">=</span><span class="n">n</span><span class="o">.</span><span class="n">weight_value</span> <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">is_leaf</span> <span class="k">else</span> <span class="n">n</span><span class="o">.</span><span class="n">split_gain</span><span class="p">,</span>
                <span class="n">Cover</span><span class="o">=</span><span class="n">n</span><span class="o">.</span><span class="n">hessian_sum</span><span class="p">,</span>
                <span class="n">Left_Cats</span><span class="o">=</span><span class="n">n</span><span class="o">.</span><span class="n">left_cats</span><span class="p">,</span>
                <span class="n">Right_Cats</span><span class="o">=</span><span class="n">n</span><span class="o">.</span><span class="n">right_cats</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Flatten list of lists using list comprehension</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">node_to_row</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tree</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_node_lists</span><span class="p">())</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">tree</span>
        <span class="p">]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span><span class="w"> </span><span class="nn">polars</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pl</span>

            <span class="k">return</span> <span class="n">pl</span><span class="o">.</span><span class="n">from_records</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span>
                <span class="p">[</span><span class="s2">&quot;Tree&quot;</span><span class="p">,</span> <span class="s2">&quot;Node&quot;</span><span class="p">],</span> <span class="n">descending</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>

            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_records</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span>
                <span class="p">[</span><span class="s2">&quot;Tree&quot;</span><span class="p">,</span> <span class="s2">&quot;Node&quot;</span><span class="p">],</span> <span class="n">ascending</span><span class="o">=</span><span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]</span>
            <span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_to_xgboost_json</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert the Perpetual model to an XGBoost JSON model structure.&quot;&quot;&quot;</span>

        <span class="c1"># Check if it&#39;s a multi-output model</span>
        <span class="n">is_multi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">classes_</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span>

        <span class="c1"># Get raw dump</span>
        <span class="n">raw_dump</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">json_dump</span><span class="p">())</span>

        <span class="c1"># Initialize XGBoost structure</span>
        <span class="n">xgb_json</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;learner&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;attributes&quot;</span><span class="p">:</span> <span class="p">{},</span>
                <span class="s2">&quot;feature_names&quot;</span><span class="p">:</span> <span class="p">[],</span>
                <span class="s2">&quot;feature_types&quot;</span><span class="p">:</span> <span class="p">[],</span>
                <span class="s2">&quot;gradient_booster&quot;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s2">&quot;model&quot;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="s2">&quot;gbtree_model_param&quot;</span><span class="p">:</span> <span class="p">{</span>
                            <span class="s2">&quot;num_parallel_tree&quot;</span><span class="p">:</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span>
                        <span class="p">},</span>
                        <span class="s2">&quot;trees&quot;</span><span class="p">:</span> <span class="p">[],</span>
                        <span class="s2">&quot;tree_info&quot;</span><span class="p">:</span> <span class="p">[],</span>
                        <span class="s2">&quot;iteration_indptr&quot;</span><span class="p">:</span> <span class="p">[],</span>
                        <span class="s2">&quot;cats&quot;</span><span class="p">:</span> <span class="p">{</span>
                            <span class="s2">&quot;enc&quot;</span><span class="p">:</span> <span class="p">[],</span>
                            <span class="s2">&quot;feature_segments&quot;</span><span class="p">:</span> <span class="p">[],</span>
                            <span class="s2">&quot;sorted_idx&quot;</span><span class="p">:</span> <span class="p">[],</span>
                        <span class="p">},</span>
                    <span class="p">},</span>
                    <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;gbtree&quot;</span><span class="p">,</span>
                <span class="p">},</span>
                <span class="s2">&quot;learner_model_param&quot;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s2">&quot;boost_from_average&quot;</span><span class="p">:</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;num_feature&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_features_</span><span class="p">),</span>
                <span class="p">},</span>
                <span class="s2">&quot;objective&quot;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;binary:logistic&quot;</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">},</span>
            <span class="s2">&quot;version&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>  <span class="c1"># Use a reasonably recent version</span>
        <span class="p">}</span>

        <span class="c1"># Fill feature names if available</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;feature_names_in_&quot;</span><span class="p">):</span>
            <span class="n">xgb_json</span><span class="p">[</span><span class="s2">&quot;learner&quot;</span><span class="p">][</span><span class="s2">&quot;feature_names&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_names_in_</span>
            <span class="n">xgb_json</span><span class="p">[</span><span class="s2">&quot;learner&quot;</span><span class="p">][</span><span class="s2">&quot;feature_types&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;float&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_features_</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xgb_json</span><span class="p">[</span><span class="s2">&quot;learner&quot;</span><span class="p">][</span><span class="s2">&quot;feature_names&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="sa">f</span><span class="s2">&quot;f</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_features_</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="n">xgb_json</span><span class="p">[</span><span class="s2">&quot;learner&quot;</span><span class="p">][</span><span class="s2">&quot;feature_types&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;float&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_features_</span>

        <span class="c1"># Objective and Base Score Handling</span>
        <span class="k">if</span> <span class="n">is_multi</span><span class="p">:</span>
            <span class="c1"># Multi-class</span>
            <span class="n">n_classes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">classes_</span><span class="p">)</span>
            <span class="n">xgb_json</span><span class="p">[</span><span class="s2">&quot;learner&quot;</span><span class="p">][</span><span class="s2">&quot;objective&quot;</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;multi:softprob&quot;</span>
            <span class="n">xgb_json</span><span class="p">[</span><span class="s2">&quot;learner&quot;</span><span class="p">][</span><span class="s2">&quot;objective&quot;</span><span class="p">][</span><span class="s2">&quot;softmax_multiclass_param&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;num_class&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_classes</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="n">xgb_json</span><span class="p">[</span><span class="s2">&quot;learner&quot;</span><span class="p">][</span><span class="s2">&quot;learner_model_param&quot;</span><span class="p">][</span><span class="s2">&quot;num_class&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_classes</span><span class="p">)</span>
            <span class="n">xgb_json</span><span class="p">[</span><span class="s2">&quot;learner&quot;</span><span class="p">][</span><span class="s2">&quot;learner_model_param&quot;</span><span class="p">][</span><span class="s2">&quot;num_target&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;1&quot;</span>

            <span class="c1"># Base score vector [0.5, 0.5, ...]</span>
            <span class="c1"># 5.0E-1</span>
            <span class="n">base_score_str</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;5.0E-1&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_classes</span><span class="p">)</span>
            <span class="n">xgb_json</span><span class="p">[</span><span class="s2">&quot;learner&quot;</span><span class="p">][</span><span class="s2">&quot;learner_model_param&quot;</span><span class="p">][</span><span class="s2">&quot;base_score&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">base_score_str</span><span class="si">}</span><span class="s2">]&quot;</span>
            <span class="p">)</span>

            <span class="n">boosters</span> <span class="o">=</span> <span class="n">raw_dump</span><span class="p">[</span><span class="s2">&quot;boosters&quot;</span><span class="p">]</span>

            <span class="n">trees</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">tree_info</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># For multi-class, we need to interleave trees if we want to follow XGBoost structure perfectly?</span>
            <span class="c1"># Or can we just dump them? iteration_indptr depends on this.</span>
            <span class="c1"># XGBoost expects trees for iteration i to be contiguous.</span>
            <span class="c1"># Perpetual stores boosters separately.</span>
            <span class="c1"># Booster 0 has trees for class 0. Booster 1 for class 1.</span>
            <span class="c1"># We need to rearrange them: Round 0 (C0, C1, C2), Round 1 (C0, C1, C2)...</span>

            <span class="c1"># Assuming all boosters have same number of trees?</span>
            <span class="n">num_trees_per_booster</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="s2">&quot;trees&quot;</span><span class="p">])</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">boosters</span><span class="p">]</span>
            <span class="n">max_trees</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">num_trees_per_booster</span><span class="p">)</span> <span class="k">if</span> <span class="n">num_trees_per_booster</span> <span class="k">else</span> <span class="mi">0</span>

            <span class="c1"># Iteration pointers: 0, 3, 6...</span>
            <span class="c1"># But what if some booster has fewer trees? (Early stopping might cause this?)</span>
            <span class="c1"># Perpetual implementation usually stops all or none?</span>
            <span class="c1"># &quot;MultiOutputBooster::fit&quot; trains them sequentially but they might have different tree counts if EarlyStopping is per-booster.</span>
            <span class="c1"># But XGBoost expects consistent num_class trees per round (or use &quot;multi:softprob&quot;?)</span>
            <span class="c1"># If we just list them, XGBoost might get confused if we don&#39;t align them.</span>

            <span class="c1"># Let&#39;s try to align them by round.</span>

            <span class="n">iteration_indptr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">current_ptr</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">for</span> <span class="n">round_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_trees</span><span class="p">):</span>
                <span class="c1"># For each class</span>
                <span class="k">for</span> <span class="n">group_id</span><span class="p">,</span> <span class="n">booster_dump</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">boosters</span><span class="p">):</span>
                    <span class="n">booster_trees</span> <span class="o">=</span> <span class="n">booster_dump</span><span class="p">[</span><span class="s2">&quot;trees&quot;</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">round_idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">booster_trees</span><span class="p">):</span>
                        <span class="n">tree</span> <span class="o">=</span> <span class="n">booster_trees</span><span class="p">[</span><span class="n">round_idx</span><span class="p">]</span>
                        <span class="n">base_score</span> <span class="o">=</span> <span class="n">booster_dump</span><span class="p">[</span><span class="s2">&quot;base_score&quot;</span><span class="p">]</span>

                        <span class="n">xgb_tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">current_ptr</span><span class="p">)</span>

                        <span class="k">if</span> <span class="n">round_idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_adjust_tree_leaves</span><span class="p">(</span><span class="n">xgb_tree</span><span class="p">,</span> <span class="n">base_score</span><span class="p">)</span>

                        <span class="n">trees</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xgb_tree</span><span class="p">)</span>
                        <span class="n">tree_info</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group_id</span><span class="p">)</span>
                        <span class="n">current_ptr</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Missing tree for this class in this round?</span>
                        <span class="c1"># Should we insert a dummy tree (0 prediction)?</span>
                        <span class="c1"># For now, let&#39;s assume balanced trees or hope XGB handles it.</span>
                        <span class="c1"># If we skip, tree_info tracks class.</span>
                        <span class="k">pass</span>

                <span class="n">iteration_indptr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_ptr</span><span class="p">)</span>

            <span class="n">xgb_json</span><span class="p">[</span><span class="s2">&quot;learner&quot;</span><span class="p">][</span><span class="s2">&quot;gradient_booster&quot;</span><span class="p">][</span><span class="s2">&quot;model&quot;</span><span class="p">][</span><span class="s2">&quot;trees&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">trees</span>
            <span class="n">xgb_json</span><span class="p">[</span><span class="s2">&quot;learner&quot;</span><span class="p">][</span><span class="s2">&quot;gradient_booster&quot;</span><span class="p">][</span><span class="s2">&quot;model&quot;</span><span class="p">][</span><span class="s2">&quot;tree_info&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tree_info</span>
            <span class="n">xgb_json</span><span class="p">[</span><span class="s2">&quot;learner&quot;</span><span class="p">][</span><span class="s2">&quot;gradient_booster&quot;</span><span class="p">][</span><span class="s2">&quot;model&quot;</span><span class="p">][</span><span class="s2">&quot;gbtree_model_param&quot;</span><span class="p">][</span>
                <span class="s2">&quot;num_trees&quot;</span>
            <span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">trees</span><span class="p">))</span>
            <span class="n">xgb_json</span><span class="p">[</span><span class="s2">&quot;learner&quot;</span><span class="p">][</span><span class="s2">&quot;gradient_booster&quot;</span><span class="p">][</span><span class="s2">&quot;model&quot;</span><span class="p">][</span><span class="s2">&quot;iteration_indptr&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">iteration_indptr</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Binary or Regression</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">objective</span> <span class="o">==</span> <span class="s2">&quot;LogLoss&quot;</span><span class="p">:</span>
                <span class="n">xgb_json</span><span class="p">[</span><span class="s2">&quot;learner&quot;</span><span class="p">][</span><span class="s2">&quot;objective&quot;</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;binary:logistic&quot;</span>
                <span class="n">xgb_json</span><span class="p">[</span><span class="s2">&quot;learner&quot;</span><span class="p">][</span><span class="s2">&quot;objective&quot;</span><span class="p">][</span><span class="s2">&quot;reg_loss_param&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;scale_pos_weight&quot;</span><span class="p">:</span> <span class="s2">&quot;1&quot;</span>
                <span class="p">}</span>
                <span class="n">xgb_json</span><span class="p">[</span><span class="s2">&quot;learner&quot;</span><span class="p">][</span><span class="s2">&quot;learner_model_param&quot;</span><span class="p">][</span><span class="s2">&quot;num_class&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;0&quot;</span>
                <span class="n">xgb_json</span><span class="p">[</span><span class="s2">&quot;learner&quot;</span><span class="p">][</span><span class="s2">&quot;learner_model_param&quot;</span><span class="p">][</span><span class="s2">&quot;num_target&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;1&quot;</span>

                <span class="c1"># Base Score</span>
                <span class="n">base_score_val</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">raw_dump</span><span class="p">[</span><span class="s2">&quot;base_score&quot;</span><span class="p">]))</span>
                <span class="n">xgb_json</span><span class="p">[</span><span class="s2">&quot;learner&quot;</span><span class="p">][</span><span class="s2">&quot;learner_model_param&quot;</span><span class="p">][</span><span class="s2">&quot;base_score&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">base_score_val</span><span class="si">:</span><span class="s2">.6E</span><span class="si">}</span><span class="s2">]&quot;</span>
                <span class="p">)</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">objective</span> <span class="o">==</span> <span class="s2">&quot;SquaredLoss&quot;</span><span class="p">:</span>
                <span class="n">xgb_json</span><span class="p">[</span><span class="s2">&quot;learner&quot;</span><span class="p">][</span><span class="s2">&quot;objective&quot;</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;reg:squarederror&quot;</span>
                <span class="n">xgb_json</span><span class="p">[</span><span class="s2">&quot;learner&quot;</span><span class="p">][</span><span class="s2">&quot;objective&quot;</span><span class="p">][</span><span class="s2">&quot;reg_loss_param&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">xgb_json</span><span class="p">[</span><span class="s2">&quot;learner&quot;</span><span class="p">][</span><span class="s2">&quot;learner_model_param&quot;</span><span class="p">][</span><span class="s2">&quot;num_class&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;0&quot;</span>
                <span class="n">xgb_json</span><span class="p">[</span><span class="s2">&quot;learner&quot;</span><span class="p">][</span><span class="s2">&quot;learner_model_param&quot;</span><span class="p">][</span><span class="s2">&quot;num_target&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;1&quot;</span>
                <span class="n">xgb_json</span><span class="p">[</span><span class="s2">&quot;learner&quot;</span><span class="p">][</span><span class="s2">&quot;learner_model_param&quot;</span><span class="p">][</span><span class="s2">&quot;base_score&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">raw_dump</span><span class="p">[</span><span class="s1">&#39;base_score&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">.6E</span><span class="si">}</span><span class="s2">]&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Objective </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">objective</span><span class="si">}</span><span class="s2"> not explicitly supported for XGBoost export. Defaulting to reg:squarederror.&quot;</span>
                <span class="p">)</span>
                <span class="n">xgb_json</span><span class="p">[</span><span class="s2">&quot;learner&quot;</span><span class="p">][</span><span class="s2">&quot;objective&quot;</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;reg:squarederror&quot;</span>
                <span class="n">xgb_json</span><span class="p">[</span><span class="s2">&quot;learner&quot;</span><span class="p">][</span><span class="s2">&quot;objective&quot;</span><span class="p">][</span><span class="s2">&quot;reg_loss_param&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">xgb_json</span><span class="p">[</span><span class="s2">&quot;learner&quot;</span><span class="p">][</span><span class="s2">&quot;learner_model_param&quot;</span><span class="p">][</span><span class="s2">&quot;num_class&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;0&quot;</span>
                <span class="n">xgb_json</span><span class="p">[</span><span class="s2">&quot;learner&quot;</span><span class="p">][</span><span class="s2">&quot;learner_model_param&quot;</span><span class="p">][</span><span class="s2">&quot;num_target&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;1&quot;</span>
                <span class="n">xgb_json</span><span class="p">[</span><span class="s2">&quot;learner&quot;</span><span class="p">][</span><span class="s2">&quot;learner_model_param&quot;</span><span class="p">][</span><span class="s2">&quot;base_score&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">raw_dump</span><span class="p">[</span><span class="s1">&#39;base_score&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">.6E</span><span class="si">}</span><span class="s2">]&quot;</span>
                <span class="p">)</span>

            <span class="n">trees</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">tree_info</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">tree_idx</span><span class="p">,</span> <span class="n">tree</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">raw_dump</span><span class="p">[</span><span class="s2">&quot;trees&quot;</span><span class="p">]):</span>
                <span class="n">xgb_tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">tree_idx</span><span class="p">)</span>
                <span class="n">trees</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xgb_tree</span><span class="p">)</span>
                <span class="n">tree_info</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="n">xgb_json</span><span class="p">[</span><span class="s2">&quot;learner&quot;</span><span class="p">][</span><span class="s2">&quot;gradient_booster&quot;</span><span class="p">][</span><span class="s2">&quot;model&quot;</span><span class="p">][</span><span class="s2">&quot;trees&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">trees</span>
            <span class="n">xgb_json</span><span class="p">[</span><span class="s2">&quot;learner&quot;</span><span class="p">][</span><span class="s2">&quot;gradient_booster&quot;</span><span class="p">][</span><span class="s2">&quot;model&quot;</span><span class="p">][</span><span class="s2">&quot;tree_info&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tree_info</span>
            <span class="n">xgb_json</span><span class="p">[</span><span class="s2">&quot;learner&quot;</span><span class="p">][</span><span class="s2">&quot;gradient_booster&quot;</span><span class="p">][</span><span class="s2">&quot;model&quot;</span><span class="p">][</span><span class="s2">&quot;gbtree_model_param&quot;</span><span class="p">][</span>
                <span class="s2">&quot;num_trees&quot;</span>
            <span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">trees</span><span class="p">))</span>
            <span class="n">xgb_json</span><span class="p">[</span><span class="s2">&quot;learner&quot;</span><span class="p">][</span><span class="s2">&quot;gradient_booster&quot;</span><span class="p">][</span><span class="s2">&quot;model&quot;</span><span class="p">][</span><span class="s2">&quot;iteration_indptr&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">trees</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">xgb_json</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_convert_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">group_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert a single Perpetual tree to XGBoost dictionary format.&quot;&quot;&quot;</span>

        <span class="n">nodes_dict</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="s2">&quot;nodes&quot;</span><span class="p">]</span>
        <span class="c1"># Convert keys to int and sort</span>
        <span class="n">sorted_keys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">nodes_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

        <span class="c1"># Mapping from Perpetual ID (int) to XGBoost Array Index (int)</span>
        <span class="n">node_map</span> <span class="o">=</span> <span class="p">{</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">):</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sorted_keys</span><span class="p">)}</span>

        <span class="n">num_nodes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sorted_keys</span><span class="p">)</span>
        <span class="c1"># print(f&quot;DEBUG: Converting tree group={group_id}. num_nodes={num_nodes}&quot;)</span>

        <span class="n">left_children</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_nodes</span>
        <span class="n">right_children</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_nodes</span>
        <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2147483647</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_nodes</span>
        <span class="n">split_indices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_nodes</span>
        <span class="n">split_conditions</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_nodes</span>
        <span class="n">split_type</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_nodes</span>
        <span class="n">sum_hessian</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_nodes</span>
        <span class="n">loss_changes</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_nodes</span>
        <span class="n">base_weights</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_nodes</span>
        <span class="n">default_left</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_nodes</span>

        <span class="n">categories</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">categories_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">categories_segments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">categories_sizes</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sorted_keys</span><span class="p">):</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">nodes_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">nid</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s2">&quot;num&quot;</span><span class="p">])</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">node_map</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span>

            <span class="c1"># print(f&quot;  DEBUG: Node {i} nid={nid} idx={idx}&quot;)</span>

            <span class="n">sum_hessian</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s2">&quot;hessian_sum&quot;</span><span class="p">]</span>
            <span class="n">base_weights</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s2">&quot;weight_value&quot;</span><span class="p">]</span>
            <span class="n">loss_changes</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;split_gain&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="s2">&quot;is_leaf&quot;</span><span class="p">]:</span>
                <span class="n">left_children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">right_children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">split_indices</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">split_conditions</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s2">&quot;weight_value&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">left_id</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s2">&quot;left_child&quot;</span><span class="p">]</span>
                <span class="n">right_id</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s2">&quot;right_child&quot;</span><span class="p">]</span>

                <span class="n">left_idx</span> <span class="o">=</span> <span class="n">node_map</span><span class="p">[</span><span class="n">left_id</span><span class="p">]</span>
                <span class="n">right_idx</span> <span class="o">=</span> <span class="n">node_map</span><span class="p">[</span><span class="n">right_id</span><span class="p">]</span>

                <span class="n">left_children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">left_idx</span>
                <span class="n">right_children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">right_idx</span>
                <span class="n">parents</span><span class="p">[</span><span class="n">left_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
                <span class="n">parents</span><span class="p">[</span><span class="n">right_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>

                <span class="n">split_indices</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s2">&quot;split_feature&quot;</span><span class="p">]</span>
                <span class="n">split_conditions</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s2">&quot;split_value&quot;</span><span class="p">]</span>

                <span class="c1"># Missing handling</span>
                <span class="c1"># If missing_node goes left</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="s2">&quot;missing_node&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">left_id</span><span class="p">:</span>
                    <span class="n">default_left</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">default_left</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="k">if</span> <span class="p">(</span>
                    <span class="s2">&quot;left_cats&quot;</span> <span class="ow">in</span> <span class="n">node</span>
                    <span class="ow">and</span> <span class="n">node</span><span class="p">[</span><span class="s2">&quot;left_cats&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s2">&quot;left_cats&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="p">):</span>
                    <span class="c1"># It&#39;s a categorical split</span>
                    <span class="n">cats</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s2">&quot;left_cats&quot;</span><span class="p">]</span>
                    <span class="c1"># XGBoost uses split_type=1 for categorical?</span>
                    <span class="c1"># Or just presence in categories_nodes?</span>
                    <span class="c1"># Docs say: split_type [default=0]: 0=numerical, 1=categorical</span>
                    <span class="n">split_type</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                    <span class="c1"># Update categorical arrays</span>
                    <span class="n">categories_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                    <span class="n">categories_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cats</span><span class="p">))</span>
                    <span class="c1"># Segment is start index.</span>
                    <span class="c1"># If this is the first one, 0. Else prev_segment + prev_size?</span>
                    <span class="c1"># Actually valid XGBoost format usually has segments as exclusive scan.</span>
                    <span class="c1"># [0, len0, len0+len1, ...]</span>
                    <span class="c1"># Wait, segments length should be same as nodes?</span>
                    <span class="c1"># Let&#39;s check logic:</span>
                    <span class="c1"># segments[i] points to start of cats for node i (in categories_nodes)</span>

                    <span class="n">next_segment</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="p">(</span><span class="n">categories_segments</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">categories_sizes</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">categories_segments</span>
                        <span class="k">else</span> <span class="mi">0</span>
                    <span class="p">)</span>
                    <span class="n">categories_segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_segment</span><span class="p">)</span>

                    <span class="n">categories</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">cats</span><span class="p">))</span>

                    <span class="c1"># split_condition for categorical is usually NaN or special?</span>
                    <span class="c1"># XGBoost JSON parser might ignore it if type is categorical</span>
                    <span class="c1"># But often it is set to something.</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;base_weights&quot;</span><span class="p">:</span> <span class="n">base_weights</span><span class="p">,</span>
            <span class="s2">&quot;default_left&quot;</span><span class="p">:</span> <span class="n">default_left</span><span class="p">,</span>
            <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">group_id</span><span class="p">,</span>
            <span class="s2">&quot;left_children&quot;</span><span class="p">:</span> <span class="n">left_children</span><span class="p">,</span>
            <span class="s2">&quot;loss_changes&quot;</span><span class="p">:</span> <span class="n">loss_changes</span><span class="p">,</span>
            <span class="s2">&quot;parents&quot;</span><span class="p">:</span> <span class="n">parents</span><span class="p">,</span>
            <span class="s2">&quot;right_children&quot;</span><span class="p">:</span> <span class="n">right_children</span><span class="p">,</span>
            <span class="s2">&quot;split_conditions&quot;</span><span class="p">:</span> <span class="n">split_conditions</span><span class="p">,</span>
            <span class="s2">&quot;split_indices&quot;</span><span class="p">:</span> <span class="n">split_indices</span><span class="p">,</span>
            <span class="s2">&quot;split_type&quot;</span><span class="p">:</span> <span class="n">split_type</span><span class="p">,</span>
            <span class="s2">&quot;sum_hessian&quot;</span><span class="p">:</span> <span class="n">sum_hessian</span><span class="p">,</span>
            <span class="s2">&quot;tree_param&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;num_deleted&quot;</span><span class="p">:</span> <span class="s2">&quot;0&quot;</span><span class="p">,</span>
                <span class="s2">&quot;num_feature&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_features_</span><span class="p">),</span>
                <span class="s2">&quot;num_nodes&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">),</span>
                <span class="s2">&quot;size_leaf_vector&quot;</span><span class="p">:</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="s2">&quot;categories&quot;</span><span class="p">:</span> <span class="n">categories</span><span class="p">,</span>
            <span class="s2">&quot;categories_nodes&quot;</span><span class="p">:</span> <span class="n">categories_nodes</span><span class="p">,</span>
            <span class="s2">&quot;categories_segments&quot;</span><span class="p">:</span> <span class="n">categories_segments</span><span class="p">,</span>
            <span class="s2">&quot;categories_sizes&quot;</span><span class="p">:</span> <span class="n">categories_sizes</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_adjust_tree_leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xgb_tree</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">adjustment</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add adjustment value to all leaves in an XGBoost tree dict.&quot;&quot;&quot;</span>
        <span class="n">left_children</span> <span class="o">=</span> <span class="n">xgb_tree</span><span class="p">[</span><span class="s2">&quot;left_children&quot;</span><span class="p">]</span>
        <span class="n">split_conditions</span> <span class="o">=</span> <span class="n">xgb_tree</span><span class="p">[</span><span class="s2">&quot;split_conditions&quot;</span><span class="p">]</span>
        <span class="n">base_weights</span> <span class="o">=</span> <span class="n">xgb_tree</span><span class="p">[</span><span class="s2">&quot;base_weights&quot;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">left</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">left_children</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">left</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>  <span class="c1"># Leaf</span>
                <span class="n">split_conditions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">adjustment</span>
                <span class="n">base_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">adjustment</span>

<div class="viewcode-block" id="PerpetualBooster.save_as_xgboost">
<a class="viewcode-back" href="../../generated/perpetual.PerpetualBooster.html#perpetual.PerpetualBooster.save_as_xgboost">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">save_as_xgboost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the model in XGBoost JSON format.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : str</span>
<span class="sd">            The path where the XGBoost-compatible model will be saved.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xgboost_json</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_xgboost_json</span><span class="p">()</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">xgboost_json</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></div>


<div class="viewcode-block" id="PerpetualBooster.save_as_onnx">
<a class="viewcode-back" href="../../generated/perpetual.PerpetualBooster.html#perpetual.PerpetualBooster.save_as_onnx">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">save_as_onnx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;perpetual_model&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the model in ONNX format.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : str</span>
<span class="sd">            The path where the ONNX model will be saved.</span>
<span class="sd">        name : str, optional, default=&quot;perpetual_model&quot;</span>
<span class="sd">            The name of the graph in the exported model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">json</span>

        <span class="kn">import</span><span class="w"> </span><span class="nn">onnx</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">onnx</span><span class="w"> </span><span class="kn">import</span> <span class="n">TensorProto</span><span class="p">,</span> <span class="n">helper</span>

        <span class="n">raw_dump</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">json_dump</span><span class="p">())</span>
        <span class="n">is_classifier</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">classes_</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span>
        <span class="n">is_multi</span> <span class="o">=</span> <span class="n">is_classifier</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">classes_</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span>
        <span class="n">n_classes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">classes_</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_classifier</span> <span class="k">else</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="s2">&quot;trees&quot;</span> <span class="ow">in</span> <span class="n">raw_dump</span><span class="p">:</span>
            <span class="n">booster_data</span> <span class="o">=</span> <span class="p">[{</span><span class="s2">&quot;trees&quot;</span><span class="p">:</span> <span class="n">raw_dump</span><span class="p">[</span><span class="s2">&quot;trees&quot;</span><span class="p">]}]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">booster_data</span> <span class="o">=</span> <span class="n">raw_dump</span><span class="p">[</span><span class="s2">&quot;boosters&quot;</span><span class="p">]</span>

        <span class="n">feature_map_inverse</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">feature_names_in_</span><span class="p">)}</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;feature_names_in_&quot;</span><span class="p">)</span>
            <span class="k">else</span> <span class="kc">None</span>
        <span class="p">)</span>

        <span class="n">nodes_treeids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nodes_nodeids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nodes_featureids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nodes_values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nodes_modes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nodes_truenodeids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nodes_falsenodeids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nodes_missing_value_tracks_true</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">target_treeids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">target_nodeids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">target_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">target_weights</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Base score handling</span>
        <span class="n">base_score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_score</span>
        <span class="k">if</span> <span class="n">is_classifier</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_multi</span><span class="p">:</span>
                <span class="n">base_values</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">base_score</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">base_values</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">base_score</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">base_values</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">base_score</span><span class="p">)]</span>

        <span class="n">global_tree_idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">b_idx</span><span class="p">,</span> <span class="n">booster</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">booster_data</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">tree_data</span> <span class="ow">in</span> <span class="n">booster</span><span class="p">[</span><span class="s2">&quot;trees&quot;</span><span class="p">]:</span>
                <span class="n">nodes_dict</span> <span class="o">=</span> <span class="n">tree_data</span><span class="p">[</span><span class="s2">&quot;nodes&quot;</span><span class="p">]</span>
                <span class="n">node_keys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">nodes_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

                <span class="n">node_id_to_idx</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node_keys</span><span class="p">):</span>
                    <span class="n">node_id_to_idx</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span> <span class="o">=</span> <span class="n">i</span>

                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">node_keys</span><span class="p">:</span>
                    <span class="n">node_dict</span> <span class="o">=</span> <span class="n">nodes_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="n">nid</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">node_dict</span><span class="p">[</span><span class="s2">&quot;num&quot;</span><span class="p">])</span>
                    <span class="n">idx_for_onnx</span> <span class="o">=</span> <span class="n">node_id_to_idx</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span>

                    <span class="n">nodes_treeids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">global_tree_idx</span><span class="p">)</span>
                    <span class="n">nodes_nodeids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx_for_onnx</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">node_dict</span><span class="p">[</span><span class="s2">&quot;is_leaf&quot;</span><span class="p">]:</span>
                        <span class="n">nodes_modes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;LEAF&quot;</span><span class="p">)</span>
                        <span class="n">nodes_featureids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">nodes_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
                        <span class="n">nodes_truenodeids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">nodes_falsenodeids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">nodes_missing_value_tracks_true</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

                        <span class="n">target_treeids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">global_tree_idx</span><span class="p">)</span>
                        <span class="n">target_nodeids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx_for_onnx</span><span class="p">)</span>
                        <span class="n">target_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b_idx</span> <span class="k">if</span> <span class="n">is_multi</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="n">target_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">node_dict</span><span class="p">[</span><span class="s2">&quot;weight_value&quot;</span><span class="p">]))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">nodes_modes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;BRANCH_LT&quot;</span><span class="p">)</span>
                        <span class="n">feat_val</span> <span class="o">=</span> <span class="n">node_dict</span><span class="p">[</span><span class="s2">&quot;split_feature&quot;</span><span class="p">]</span>
                        <span class="n">f_idx</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">feat_val</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                            <span class="n">f_idx</span> <span class="o">=</span> <span class="n">feat_val</span>
                        <span class="k">elif</span> <span class="n">feature_map_inverse</span> <span class="ow">and</span> <span class="n">feat_val</span> <span class="ow">in</span> <span class="n">feature_map_inverse</span><span class="p">:</span>
                            <span class="n">f_idx</span> <span class="o">=</span> <span class="n">feature_map_inverse</span><span class="p">[</span><span class="n">feat_val</span><span class="p">]</span>
                        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">feat_val</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">feat_val</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
                            <span class="n">f_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">feat_val</span><span class="p">)</span>

                        <span class="n">nodes_featureids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f_idx</span><span class="p">)</span>
                        <span class="n">nodes_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">node_dict</span><span class="p">[</span><span class="s2">&quot;split_value&quot;</span><span class="p">]))</span>

                        <span class="n">tracks_true</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">if</span> <span class="n">node_dict</span><span class="p">[</span><span class="s2">&quot;missing_node&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">node_dict</span><span class="p">[</span><span class="s2">&quot;left_child&quot;</span><span class="p">]:</span>
                            <span class="n">tracks_true</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">nodes_missing_value_tracks_true</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tracks_true</span><span class="p">)</span>

                        <span class="n">nodes_truenodeids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">node_id_to_idx</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">node_dict</span><span class="p">[</span><span class="s2">&quot;left_child&quot;</span><span class="p">])]</span>
                        <span class="p">)</span>
                        <span class="n">nodes_falsenodeids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">node_id_to_idx</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">node_dict</span><span class="p">[</span><span class="s2">&quot;right_child&quot;</span><span class="p">])]</span>
                        <span class="p">)</span>

                <span class="n">global_tree_idx</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">input_name</span> <span class="o">=</span> <span class="s2">&quot;input&quot;</span>
        <span class="n">input_type</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">make_tensor_value_info</span><span class="p">(</span>
            <span class="n">input_name</span><span class="p">,</span> <span class="n">TensorProto</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_features_</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">raw_scores_name</span> <span class="o">=</span> <span class="s2">&quot;raw_scores&quot;</span>
        <span class="n">reg_node</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
            <span class="s2">&quot;TreeEnsembleRegressor&quot;</span><span class="p">,</span>
            <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">input_name</span><span class="p">],</span>
            <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="n">raw_scores_name</span><span class="p">],</span>
            <span class="n">domain</span><span class="o">=</span><span class="s2">&quot;ai.onnx.ml&quot;</span><span class="p">,</span>
            <span class="n">nodes_treeids</span><span class="o">=</span><span class="n">nodes_treeids</span><span class="p">,</span>
            <span class="n">nodes_nodeids</span><span class="o">=</span><span class="n">nodes_nodeids</span><span class="p">,</span>
            <span class="n">nodes_featureids</span><span class="o">=</span><span class="n">nodes_featureids</span><span class="p">,</span>
            <span class="n">nodes_values</span><span class="o">=</span><span class="n">nodes_values</span><span class="p">,</span>
            <span class="n">nodes_modes</span><span class="o">=</span><span class="n">nodes_modes</span><span class="p">,</span>
            <span class="n">nodes_truenodeids</span><span class="o">=</span><span class="n">nodes_truenodeids</span><span class="p">,</span>
            <span class="n">nodes_falsenodeids</span><span class="o">=</span><span class="n">nodes_falsenodeids</span><span class="p">,</span>
            <span class="n">nodes_missing_value_tracks_true</span><span class="o">=</span><span class="n">nodes_missing_value_tracks_true</span><span class="p">,</span>
            <span class="n">target_treeids</span><span class="o">=</span><span class="n">target_treeids</span><span class="p">,</span>
            <span class="n">target_nodeids</span><span class="o">=</span><span class="n">target_nodeids</span><span class="p">,</span>
            <span class="n">target_ids</span><span class="o">=</span><span class="n">target_ids</span><span class="p">,</span>
            <span class="n">target_weights</span><span class="o">=</span><span class="n">target_weights</span><span class="p">,</span>
            <span class="n">base_values</span><span class="o">=</span><span class="n">base_values</span><span class="p">,</span>
            <span class="n">n_targets</span><span class="o">=</span><span class="n">n_classes</span> <span class="k">if</span> <span class="n">is_multi</span> <span class="k">else</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;PerpetualTreeEnsemble&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">reg_node</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">is_classifier</span><span class="p">:</span>
            <span class="c1"># Prepare class labels mapping</span>
            <span class="n">classes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classes_</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">))</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">classes</span><span class="p">):</span>
                <span class="n">tensor_type</span> <span class="o">=</span> <span class="n">TensorProto</span><span class="o">.</span><span class="n">INT64</span>
                <span class="n">classes_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">classes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">))</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">classes</span><span class="p">):</span>
                <span class="n">tensor_type</span> <span class="o">=</span> <span class="n">TensorProto</span><span class="o">.</span><span class="n">FLOAT</span>
                <span class="n">classes_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">classes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tensor_type</span> <span class="o">=</span> <span class="n">TensorProto</span><span class="o">.</span><span class="n">STRING</span>
                <span class="n">classes_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">classes</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

            <span class="n">classes_name</span> <span class="o">=</span> <span class="s2">&quot;class_labels&quot;</span>
            <span class="k">if</span> <span class="n">tensor_type</span> <span class="o">==</span> <span class="n">TensorProto</span><span class="o">.</span><span class="n">STRING</span><span class="p">:</span>
                <span class="n">classes_const_node</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
                    <span class="s2">&quot;Constant&quot;</span><span class="p">,</span>
                    <span class="p">[],</span>
                    <span class="p">[</span><span class="n">classes_name</span><span class="p">],</span>
                    <span class="n">value</span><span class="o">=</span><span class="n">helper</span><span class="o">.</span><span class="n">make_tensor</span><span class="p">(</span>
                        <span class="n">name</span><span class="o">=</span><span class="s2">&quot;classes_tensor&quot;</span><span class="p">,</span>
                        <span class="n">data_type</span><span class="o">=</span><span class="n">tensor_type</span><span class="p">,</span>
                        <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">classes</span><span class="p">)],</span>
                        <span class="n">vals</span><span class="o">=</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">classes_array</span><span class="p">],</span>
                    <span class="p">),</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">classes_const_node</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
                    <span class="s2">&quot;Constant&quot;</span><span class="p">,</span>
                    <span class="p">[],</span>
                    <span class="p">[</span><span class="n">classes_name</span><span class="p">],</span>
                    <span class="n">value</span><span class="o">=</span><span class="n">helper</span><span class="o">.</span><span class="n">make_tensor</span><span class="p">(</span>
                        <span class="n">name</span><span class="o">=</span><span class="s2">&quot;classes_tensor&quot;</span><span class="p">,</span>
                        <span class="n">data_type</span><span class="o">=</span><span class="n">tensor_type</span><span class="p">,</span>
                        <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">classes</span><span class="p">)],</span>
                        <span class="n">vals</span><span class="o">=</span><span class="n">classes_array</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                    <span class="p">),</span>
                <span class="p">)</span>
            <span class="n">ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">classes_const_node</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">is_multi</span><span class="p">:</span>
                <span class="n">prob_name</span> <span class="o">=</span> <span class="s2">&quot;probabilities&quot;</span>
                <span class="n">softmax_node</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
                    <span class="s2">&quot;Softmax&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">raw_scores_name</span><span class="p">],</span> <span class="p">[</span><span class="n">prob_name</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
                <span class="p">)</span>
                <span class="n">label_idx_name</span> <span class="o">=</span> <span class="s2">&quot;label_idx&quot;</span>
                <span class="n">argmax_node</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
                    <span class="s2">&quot;ArgMax&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">prob_name</span><span class="p">],</span> <span class="p">[</span><span class="n">label_idx_name</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">)</span>
                <span class="n">label_name</span> <span class="o">=</span> <span class="s2">&quot;label&quot;</span>
                <span class="n">gather_node</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
                    <span class="s2">&quot;Gather&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">classes_name</span><span class="p">,</span> <span class="n">label_idx_name</span><span class="p">],</span> <span class="p">[</span><span class="n">label_name</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">)</span>
                <span class="n">ops</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">softmax_node</span><span class="p">,</span> <span class="n">argmax_node</span><span class="p">,</span> <span class="n">gather_node</span><span class="p">])</span>
                <span class="n">outputs</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">helper</span><span class="o">.</span><span class="n">make_tensor_value_info</span><span class="p">(</span><span class="n">label_name</span><span class="p">,</span> <span class="n">tensor_type</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">]),</span>
                    <span class="n">helper</span><span class="o">.</span><span class="n">make_tensor_value_info</span><span class="p">(</span>
                        <span class="n">prob_name</span><span class="p">,</span> <span class="n">TensorProto</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_classes</span><span class="p">]</span>
                    <span class="p">),</span>
                <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">p_name</span> <span class="o">=</span> <span class="s2">&quot;p&quot;</span>
                <span class="n">sigmoid_node</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span><span class="s2">&quot;Sigmoid&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">raw_scores_name</span><span class="p">],</span> <span class="p">[</span><span class="n">p_name</span><span class="p">])</span>
                <span class="n">one_name</span> <span class="o">=</span> <span class="s2">&quot;one&quot;</span>
                <span class="n">one_node</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
                    <span class="s2">&quot;Constant&quot;</span><span class="p">,</span>
                    <span class="p">[],</span>
                    <span class="p">[</span><span class="n">one_name</span><span class="p">],</span>
                    <span class="n">value</span><span class="o">=</span><span class="n">helper</span><span class="o">.</span><span class="n">make_tensor</span><span class="p">(</span><span class="s2">&quot;one_v&quot;</span><span class="p">,</span> <span class="n">TensorProto</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]),</span>
                <span class="p">)</span>
                <span class="n">one_minus_p_name</span> <span class="o">=</span> <span class="s2">&quot;one_minus_p&quot;</span>
                <span class="n">sub_node</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
                    <span class="s2">&quot;Sub&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">one_name</span><span class="p">,</span> <span class="n">p_name</span><span class="p">],</span> <span class="p">[</span><span class="n">one_minus_p_name</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">prob_name</span> <span class="o">=</span> <span class="s2">&quot;probabilities&quot;</span>
                <span class="n">concat_node</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
                    <span class="s2">&quot;Concat&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">one_minus_p_name</span><span class="p">,</span> <span class="n">p_name</span><span class="p">],</span> <span class="p">[</span><span class="n">prob_name</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
                <span class="p">)</span>
                <span class="n">label_idx_name</span> <span class="o">=</span> <span class="s2">&quot;label_idx&quot;</span>
                <span class="n">argmax_node</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
                    <span class="s2">&quot;ArgMax&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">prob_name</span><span class="p">],</span> <span class="p">[</span><span class="n">label_idx_name</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">)</span>
                <span class="n">label_name</span> <span class="o">=</span> <span class="s2">&quot;label&quot;</span>
                <span class="n">gather_node</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
                    <span class="s2">&quot;Gather&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">classes_name</span><span class="p">,</span> <span class="n">label_idx_name</span><span class="p">],</span> <span class="p">[</span><span class="n">label_name</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">)</span>
                <span class="n">ops</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">sigmoid_node</span><span class="p">,</span>
                        <span class="n">one_node</span><span class="p">,</span>
                        <span class="n">sub_node</span><span class="p">,</span>
                        <span class="n">concat_node</span><span class="p">,</span>
                        <span class="n">argmax_node</span><span class="p">,</span>
                        <span class="n">gather_node</span><span class="p">,</span>
                    <span class="p">]</span>
                <span class="p">)</span>
                <span class="n">outputs</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">helper</span><span class="o">.</span><span class="n">make_tensor_value_info</span><span class="p">(</span><span class="n">label_name</span><span class="p">,</span> <span class="n">tensor_type</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">]),</span>
                    <span class="n">helper</span><span class="o">.</span><span class="n">make_tensor_value_info</span><span class="p">(</span>
                        <span class="n">prob_name</span><span class="p">,</span> <span class="n">TensorProto</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
                    <span class="p">),</span>
                <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prediction_name</span> <span class="o">=</span> <span class="s2">&quot;prediction&quot;</span>
            <span class="n">reg_node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">prediction_name</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">helper</span><span class="o">.</span><span class="n">make_tensor_value_info</span><span class="p">(</span>
                    <span class="n">prediction_name</span><span class="p">,</span> <span class="n">TensorProto</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="p">]</span>

        <span class="n">graph_def</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">make_graph</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="p">[</span><span class="n">input_type</span><span class="p">],</span> <span class="n">outputs</span><span class="p">)</span>
        <span class="n">model_def</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">make_model</span><span class="p">(</span>
            <span class="n">graph_def</span><span class="p">,</span>
            <span class="n">producer_name</span><span class="o">=</span><span class="s2">&quot;perpetual&quot;</span><span class="p">,</span>
            <span class="n">opset_imports</span><span class="o">=</span><span class="p">[</span>
                <span class="n">helper</span><span class="o">.</span><span class="n">make_opsetid</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="mi">13</span><span class="p">),</span>
                <span class="n">helper</span><span class="o">.</span><span class="n">make_opsetid</span><span class="p">(</span><span class="s2">&quot;ai.onnx.ml&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
            <span class="p">],</span>
        <span class="p">)</span>
        <span class="n">model_def</span><span class="o">.</span><span class="n">ir_version</span> <span class="o">=</span> <span class="mi">6</span>
        <span class="n">onnx</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">model_def</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2026, Mutlu Simsek, Serkan Korkmaz, Pieter Pel.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>