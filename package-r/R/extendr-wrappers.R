# Generated by extendr
# This file provides R wrappers for the Rust functions and classes

#' @docType package
#' @usage NULL
#' @useDynLib perpetual, .registration = TRUE
NULL

#' Test binding function
#' @return A test string from Rust
#' @export
test_binding <- function() {
  .Call("wrap__test_binding", PACKAGE = "perpetual")
}

# Helper function to create a PerpetualBooster instance object
.make_booster_instance <- function(ptr) {
  self <- new.env(parent = emptyenv())
  self$.ptr <- ptr
  class(self) <- "PerpetualBooster"
  
  self$fit <- function(flat_data, rows, cols, y) {
    .Call("wrap__PerpetualBooster__fit", self$.ptr, flat_data, as.integer(rows), as.integer(cols), y, PACKAGE = "perpetual")
    invisible(self)
  }
  
  self$predict <- function(flat_data, rows, cols) {
    .Call("wrap__PerpetualBooster__predict", self$.ptr, flat_data, as.integer(rows), as.integer(cols), PACKAGE = "perpetual")
  }
  
  self$predict_proba <- function(flat_data, rows, cols) {
    .Call("wrap__PerpetualBooster__predict_proba", self$.ptr, flat_data, as.integer(rows), as.integer(cols), PACKAGE = "perpetual")
  }
  
  self$save_booster <- function(path) {
    .Call("wrap__PerpetualBooster__save_booster", self$.ptr, path, PACKAGE = "perpetual")
    invisible(self)
  }
  
  self$json_dump <- function() {
    .Call("wrap__PerpetualBooster__json_dump", self$.ptr, PACKAGE = "perpetual")
  }
  
  self$number_of_trees <- function() {
    .Call("wrap__PerpetualBooster__number_of_trees", self$.ptr, PACKAGE = "perpetual")
  }
  
  self$base_score <- function() {
    .Call("wrap__PerpetualBooster__base_score", self$.ptr, PACKAGE = "perpetual")
  }
  
  self
}

#' PerpetualBooster Class
#'
#' A gradient boosting machine implementation.
#' @export
PerpetualBooster <- local({
  new <- function(
    objective = NULL,
    budget = NULL,
    max_bin = NULL,
    num_threads = NULL,
    missing = NULL,
    allow_missing_splits = NULL,
    create_missing_branch = NULL,
    missing_node_treatment = NULL,
    log_iterations = NULL,
    quantile = NULL,
    reset = NULL,
    timeout = NULL,
    iteration_limit = NULL,
    memory_limit = NULL,
    stopping_rounds = NULL
  ) {
    # Convert NULL to appropriate NA types for the .Call
    if (is.null(objective)) objective <- NA_character_
    if (is.null(budget)) budget <- NA_real_
    if (is.null(max_bin)) max_bin <- NA_integer_
    if (is.null(num_threads)) num_threads <- NA_integer_
    if (is.null(missing)) missing <- NA_real_
    if (is.null(allow_missing_splits)) allow_missing_splits <- NA
    if (is.null(create_missing_branch)) create_missing_branch <- NA
    if (is.null(missing_node_treatment)) missing_node_treatment <- NA_character_
    if (is.null(log_iterations)) log_iterations <- NA_integer_
    if (is.null(quantile)) quantile <- NA_real_
    if (is.null(reset)) reset <- NA
    if (is.null(timeout)) timeout <- NA_real_
    if (is.null(iteration_limit)) iteration_limit <- NA_integer_
    if (is.null(memory_limit)) memory_limit <- NA_real_
    if (is.null(stopping_rounds)) stopping_rounds <- NA_integer_
    
    ptr <- .Call("wrap__PerpetualBooster__new",
      objective,
      budget,
      max_bin,
      num_threads,
      missing,
      allow_missing_splits,
      create_missing_branch,
      missing_node_treatment,
      log_iterations,
      quantile,
      reset,
      timeout,
      iteration_limit,
      memory_limit,
      stopping_rounds,
      PACKAGE = "perpetual"
    )
    
    .make_booster_instance(ptr)
  }
  
  load_booster <- function(path) {
    ptr <- .Call("wrap__PerpetualBooster__load_booster", path, PACKAGE = "perpetual")
    .make_booster_instance(ptr)
  }
  
  # Return a list that acts like a class factory
  structure(
    list(new = new, load_booster = load_booster),
    class = "PerpetualBoosterClass"
  )
})
