{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Uplift Modeling with the Criteo Uplift Dataset\n",
    "\n",
    "This notebook demonstrates uplift modeling using the Criteo Uplift Dataset. Uplift modeling (also known as CATE — Conditional Average Treatment Effect) aims to predict the incremental impact of an action (the \"treatment\") on an individual's behavioral outcome.\n",
    "\n",
    "We will demonstrate how to use Perpetual's causal inference tools:\n",
    "* `UpliftBooster` (R-Learner)\n",
    "* Meta-learners: `SLearner`, `TLearner`, `XLearner`, `DRLearner` (Doubly Robust)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "\n",
    "import matplotlib.pyplot as plt\n",
    "import pandas as pd\n",
    "import requests\n",
    "from perpetual.causal_metrics import auuc, cumulative_gain_curve, qini_coefficient\n",
    "from perpetual.meta_learners import DRLearner, SLearner, TLearner, XLearner\n",
    "from perpetual.uplift import UpliftBooster\n",
    "from sklearn.model_selection import train_test_split\n",
    "\n",
    "# 1. Download Criteo Uplift Dataset\n",
    "dataset_gz = \"criteo-uplift-v2.1.csv.gz\"\n",
    "\n",
    "mirrors = [\n",
    "    \"http://go.criteo.net/criteo-research-uplift-v2.1.csv.gz\",\n",
    "    \"https://criteostorage.blob.core.windows.net/criteo-research-datasets/criteo-uplift-v2.1.csv.gz\",\n",
    "]\n",
    "\n",
    "\n",
    "def download_dataset(url, filename):\n",
    "    print(f\"Attempting to download from: {url}\")\n",
    "    try:\n",
    "        response = requests.get(url, stream=True, timeout=10)\n",
    "        response.raise_for_status()\n",
    "        with open(filename, \"wb\") as f:\n",
    "            for chunk in response.iter_content(chunk_size=8192):\n",
    "                f.write(chunk)\n",
    "        print(\"Download complete.\")\n",
    "        return True\n",
    "    except Exception as e:\n",
    "        print(f\"Download failed from {url}: {e}\")\n",
    "        return False\n",
    "\n",
    "\n",
    "if not os.path.exists(dataset_gz):\n",
    "    success = False\n",
    "    for url in mirrors:\n",
    "        if download_dataset(url, dataset_gz):\n",
    "            success = True\n",
    "            break\n",
    "    if not success:\n",
    "        raise RuntimeError(\n",
    "            \"Download failed. Please download manually and place in this folder.\"\n",
    "        )\n",
    "else:\n",
    "    print(f\"Dataset '{dataset_gz}' already exists.\")\n",
    "\n",
    "# 2. Load and Preprocess\n",
    "print(\"Loading dataset...\")\n",
    "df = pd.read_csv(dataset_gz, compression=\"gzip\")\n",
    "\n",
    "# --- PERFORMANCE OPTIMIZATION ---\n",
    "# The full dataset has ~25M rows. We subsample to 50k rows for this tutorial\n",
    "# to ensure all models fit in under 10 seconds.\n",
    "SAMPLE_SIZE = 50_000\n",
    "print(f\"Subsampling to {SAMPLE_SIZE} rows for speed...\")\n",
    "df = df.sample(n=SAMPLE_SIZE, random_state=42).reset_index(drop=True)\n",
    "# --------------------------------\n",
    "\n",
    "y = df[\"conversion\"].astype(int)\n",
    "w = df[\"treatment\"].astype(int)\n",
    "features = [\n",
    "    col\n",
    "    for col in df.columns\n",
    "    if col not in [\"treatment\", \"conversion\", \"exposure\", \"visit\"]\n",
    "]\n",
    "X = df[features].copy()\n",
    "\n",
    "X_train, X_test, w_train, w_test, y_train, y_test = train_test_split(\n",
    "    X, w, y, test_size=0.3, random_state=42\n",
    ")\n",
    "print(f\"Training set size: {X_train.shape[0]}\")\n",
    "df.head()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2. R-Learner (UpliftBooster)\n",
    "\n",
    "The `UpliftBooster` uses the **R-Learner** meta-algorithm. We use small budgets and an `iteration_limit` to keep the tutorial fast."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "budget = 0.1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Initialize and fit UpliftBooster\n",
    "ub = UpliftBooster(\n",
    "    outcome_budget=budget,\n",
    "    propensity_budget=budget,\n",
    "    effect_budget=budget,\n",
    ")\n",
    "ub.fit(X_train, w_train, y_train)\n",
    "\n",
    "# Predicted Treatment Effect\n",
    "uplift_r = ub.predict(X_test)\n",
    "print(f\"Average Predicted Uplift (R-Learner): {uplift_r.mean():.4f}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 2.1 Interaction Constraints\n",
    "\n",
    "Perpetual allows you to enforce **Interaction Constraints**. This is useful when you know that certain features should only interact with each other, or should not interact at all."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Enforce that feature 0 and feature 1 can interact\n",
    "interaction_constraints = [[0, 1]]\n",
    "ub_constrained = UpliftBooster(\n",
    "    outcome_budget=budget,\n",
    "    propensity_budget=budget,\n",
    "    effect_budget=budget,\n",
    "    interaction_constraints=interaction_constraints,\n",
    ")\n",
    "ub_constrained.fit(X_train, w_train, y_train)\n",
    "\n",
    "uplift_constrained = ub_constrained.predict(X_test)\n",
    "print(f\"Average Uplift (Constrained): {uplift_constrained.mean():.4f}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3. Comparing with Meta-Learners\n",
    "\n",
    "Meta-learners are algorithms that decompose the causal problem into one or more supervised learning problems."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# S-Learner: Single model with treatment as feature\n",
    "sl = SLearner(budget=budget)\n",
    "sl.fit(X_train, w_train, y_train)\n",
    "uplift_s = sl.predict(X_test)\n",
    "\n",
    "# T-Learner: Two models (one per treatment group)\n",
    "tl = TLearner(budget=budget)\n",
    "tl.fit(X_train, w_train, y_train)\n",
    "uplift_t = tl.predict(X_test)\n",
    "\n",
    "# X-Learner: Two-stage learner with imputation\n",
    "xl = XLearner(budget=budget)\n",
    "xl.fit(X_train, w_train, y_train)\n",
    "uplift_x = xl.predict(X_test)\n",
    "\n",
    "# DR-Learner: Doubly Robust / AIPW\n",
    "dr = DRLearner(budget=budget, clip=0.01)\n",
    "dr.fit(X_train, w_train, y_train)\n",
    "uplift_dr = dr.predict(X_test)\n",
    "\n",
    "print(f\"Avg Uplift S:  {uplift_s.mean():.4f}\")\n",
    "print(f\"Avg Uplift T:  {uplift_t.mean():.4f}\")\n",
    "print(f\"Avg Uplift X:  {uplift_x.mean():.4f}\")\n",
    "print(f\"Avg Uplift DR: {uplift_dr.mean():.4f}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 4. Evaluation: Uplift Curve\n",
    "\n",
    "Since we don't know the \"ground truth\" individual effect, we use the Cumulative Gain (Uplift) curve to evaluate performance."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# --- Uplift Gain Curves ---\n",
    "plt.figure(figsize=(10, 6))\n",
    "for label, scores in [\n",
    "    (\"R-Learner\", uplift_r),\n",
    "    (\"X-Learner\", uplift_x),\n",
    "    (\"DR-Learner\", uplift_dr),\n",
    "]:\n",
    "    fracs, gains = cumulative_gain_curve(y_test, w_test, scores)\n",
    "    plt.plot(fracs, gains, label=label)\n",
    "\n",
    "plt.plot([0, 1], [0, 0], \"k--\", label=\"Random\")\n",
    "plt.title(\"Cumulative Uplift Gain — Criteo Dataset (Subsampled)\")\n",
    "plt.xlabel(\"Population % Sorted by Predicted Uplift\")\n",
    "plt.ylabel(\"Cumulative Gain\")\n",
    "plt.legend()\n",
    "plt.show()\n",
    "\n",
    "# --- AUUC & Qini ---\n",
    "for label, scores in [\n",
    "    (\"R-Learner\", uplift_r),\n",
    "    (\"S-Learner\", uplift_s),\n",
    "    (\"T-Learner\", uplift_t),\n",
    "    (\"X-Learner\", uplift_x),\n",
    "    (\"DR-Learner\", uplift_dr),\n",
    "]:\n",
    "    a = auuc(y_test, w_test, scores, normalize=True)\n",
    "    q = qini_coefficient(y_test, w_test, scores)\n",
    "    print(f\"{label:12s}  AUUC={a:+.4f}  Qini={q:+.4f}\")"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "forust-main-perp-oss (3.13.7)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
